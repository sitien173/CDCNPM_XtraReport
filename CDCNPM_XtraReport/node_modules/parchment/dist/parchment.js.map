{"version":3,"sources":["webpack://Parchment/webpack/universalModuleDefinition","webpack://Parchment/webpack/bootstrap","webpack://Parchment/./src/scope.ts","webpack://Parchment/./src/collection/linked-list.ts","webpack://Parchment/./src/error.ts","webpack://Parchment/./src/registry.ts","webpack://Parchment/./src/blot/abstract/shadow.ts","webpack://Parchment/./src/blot/abstract/parent.ts","webpack://Parchment/./src/blot/abstract/container.ts","webpack://Parchment/./src/blot/abstract/leaf.ts","webpack://Parchment/./src/attributor/attributor.ts","webpack://Parchment/./src/attributor/class.ts","webpack://Parchment/./src/attributor/style.ts","webpack://Parchment/./src/attributor/store.ts","webpack://Parchment/./src/blot/inline.ts","webpack://Parchment/./src/blot/block.ts","webpack://Parchment/./src/blot/embed.ts","webpack://Parchment/./src/blot/scroll.ts","webpack://Parchment/./src/blot/text.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Scope","this","head","tail","length","nodes","insertBefore","rest","slice","append","index","next","iterator","cur","node","refNode","remove","prev","target","contains","curNode","ret","inclusive","callback","startNode","offset","find","curIndex","curLength","Math","min","reduce","memo","push","ParchmentError","Error","message","super","constructor","attributes","classes","tags","types","bubble","blots","has","parentNode","scroll","input","match","query","blotClass","Node","nodeType","TEXT_NODE","blot","set","domNode","scope","ANY","Text","text","LEVEL","BLOCK","block","INLINE","inline","HTMLElement","getAttribute","split","some","tagName","TYPE","definitions","map","register","definition","blotName","attrName","keyName","className","Array","isArray","toUpperCase","forEach","tag","WeakMap","parseInt","toString","document","createElement","indexOf","classList","add","cloneNode","parent","removeChild","delete","isolate","BLOT","wrap","ATTRIBUTE","statics","format","def","ref","undefined","children","_context","requiredContainer","detach","replacement","_force","_mutations","wrapper","appendChild","makeAttachedBlot","e","from","childNodes","child","replaceChild","attach","uiNode","build","other","uiClass","setAttribute","firstChild","filter","reverse","err","forEachAt","childLength","deleteAt","criteria","descendant","Number","MAX_VALUE","descendants","lengthLeft","childIndex","concat","done","allowedChildren","BLOCK_BLOT","splitAfter","unwrap","formatAt","insertAt","childBlot","refBlot","refDomNode","nextSibling","targetParent","context","optimize","enforceAllowedChildren","defaultChild","position","path","moveChildren","replaceWith","force","after","clone","_length","mutations","addedNodes","removedNodes","mutation","type","body","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","sort","a","b","DOCUMENT_POSITION_FOLLOWING","checkMerge","_domNode","_inclusive","INLINE_BLOT","options","attributeBit","whitelist","item","canAdd","_node","replace","removeAttribute","prefix","join","camelize","parts","part","trim","style","attribute","keys","styles","attr","copy","toLowerCase","formats","values","obj1","obj2","prop","isEqual","update","move","_scroll","OBSERVER_CONFIG","characterData","characterDataOldValue","childList","subtree","registry","observer","MutationObserver","observe","disconnect","mutationsMap","records","takeRecords","pop","mark","markParent","remaining","previousSibling","grandChild","createTextNode","data","splitText"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAmB,UAAID,IAEvBD,EAAgB,UAAIC,IARtB,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,+DClFrD,IAAIC,E,smBACJ,SAAWA,GACPA,EAAMA,EAAY,KAAI,GAAK,OAC3BA,EAAMA,EAAa,MAAI,IAAM,QAC7BA,EAAMA,EAAiB,UAAI,IAAM,YACjCA,EAAMA,EAAY,KAAI,IAAM,OAC5BA,EAAMA,EAAc,OAAI,GAAK,SAC7BA,EAAMA,EAAa,MAAI,IAAM,QAC7BA,EAAMA,EAAkB,WAAI,IAAM,aAClCA,EAAMA,EAAmB,YAAI,GAAK,cAClCA,EAAMA,EAAuB,gBAAI,GAAK,kBACtCA,EAAMA,EAAwB,iBAAI,GAAK,mBACvCA,EAAMA,EAAW,IAAI,IAAM,MAX/B,CAYGA,IAAUA,EAAQ,KACN,QC+JA,MA7Kf,MACI,cACIC,KAAKC,KAAO,KACZD,KAAKE,KAAO,KACZF,KAAKG,OAAS,EAElB,UAAUC,GAEN,GADAJ,KAAKK,aAAaD,EAAM,GAAI,MACxBA,EAAMD,OAAS,EAAG,CAClB,MAAMG,EAAOF,EAAMG,MAAM,GACzBP,KAAKQ,UAAUF,IAGvB,GAAGG,GACC,MAAMC,EAAOV,KAAKW,WAClB,IAAIC,EAAMF,IACV,KAAOE,GAAOH,EAAQ,GAClBA,GAAS,EACTG,EAAMF,IAEV,OAAOE,EAEX,SAASC,GACL,MAAMH,EAAOV,KAAKW,WAClB,IAAIC,EAAMF,IACV,KAAOE,GAAK,CACR,GAAIA,IAAQC,EACR,OAAO,EAEXD,EAAMF,IAEV,OAAO,EAEX,QAAQG,GACJ,MAAMH,EAAOV,KAAKW,WAClB,IAAIC,EAAMF,IACND,EAAQ,EACZ,KAAOG,GAAK,CACR,GAAIA,IAAQC,EACR,OAAOJ,EAEXA,GAAS,EACTG,EAAMF,IAEV,OAAQ,EAEZ,aAAaG,EAAMC,GACH,MAARD,IAGJb,KAAKe,OAAOF,GACZA,EAAKH,KAAOI,EACG,MAAXA,GACAD,EAAKG,KAAOF,EAAQE,KACA,MAAhBF,EAAQE,OACRF,EAAQE,KAAKN,KAAOG,GAExBC,EAAQE,KAAOH,EACXC,IAAYd,KAAKC,OACjBD,KAAKC,KAAOY,IAGE,MAAbb,KAAKE,MACVF,KAAKE,KAAKQ,KAAOG,EACjBA,EAAKG,KAAOhB,KAAKE,KACjBF,KAAKE,KAAOW,IAGZA,EAAKG,KAAO,KACZhB,KAAKC,KAAOD,KAAKE,KAAOW,GAE5Bb,KAAKG,QAAU,GAEnB,OAAOc,GACH,IAAIR,EAAQ,EACRG,EAAMZ,KAAKC,KACf,KAAc,MAAPW,GAAa,CAChB,GAAIA,IAAQK,EACR,OAAOR,EAEXA,GAASG,EAAIT,SACbS,EAAMA,EAAIF,KAEd,OAAQ,EAEZ,OAAOG,GACEb,KAAKkB,SAASL,KAGF,MAAbA,EAAKG,OACLH,EAAKG,KAAKN,KAAOG,EAAKH,MAET,MAAbG,EAAKH,OACLG,EAAKH,KAAKM,KAAOH,EAAKG,MAEtBH,IAASb,KAAKC,OACdD,KAAKC,KAAOY,EAAKH,MAEjBG,IAASb,KAAKE,OACdF,KAAKE,KAAOW,EAAKG,MAErBhB,KAAKG,QAAU,GAEnB,SAASgB,EAAUnB,KAAKC,MAEpB,MAAO,KACH,MAAMmB,EAAMD,EAIZ,OAHe,MAAXA,IACAA,EAAUA,EAAQT,MAEfU,GAGf,KAAKX,EAAOY,GAAY,GACpB,MAAMX,EAAOV,KAAKW,WAClB,IAAIC,EAAMF,IACV,KAAOE,GAAK,CACR,MAAMT,EAASS,EAAIT,SACnB,GAAIM,EAAQN,GACPkB,GACGZ,IAAUN,IACG,MAAZS,EAAIF,MAAsC,IAAtBE,EAAIF,KAAKP,UAClC,MAAO,CAACS,EAAKH,GAEjBA,GAASN,EACTS,EAAMF,IAEV,MAAO,CAAC,KAAM,GAElB,QAAQY,GACJ,MAAMZ,EAAOV,KAAKW,WAClB,IAAIC,EAAMF,IACV,KAAOE,GACHU,EAASV,GACTA,EAAMF,IAGd,UAAUD,EAAON,EAAQmB,GACrB,GAAInB,GAAU,EACV,OAEJ,MAAOoB,EAAWC,GAAUxB,KAAKyB,KAAKhB,GACtC,IAAIiB,EAAWjB,EAAQe,EACvB,MAAMd,EAAOV,KAAKW,SAASY,GAC3B,IAAIX,EAAMF,IACV,KAAOE,GAAOc,EAAWjB,EAAQN,GAAQ,CACrC,MAAMwB,EAAYf,EAAIT,SAClBM,EAAQiB,EACRJ,EAASV,EAAKH,EAAQiB,EAAUE,KAAKC,IAAI1B,EAAQuB,EAAWC,EAAYlB,IAGxEa,EAASV,EAAK,EAAGgB,KAAKC,IAAIF,EAAWlB,EAAQN,EAASuB,IAE1DA,GAAYC,EACZf,EAAMF,KAGd,IAAIY,GACA,OAAOtB,KAAK8B,OAAO,CAACC,EAAMnB,KACtBmB,EAAKC,KAAKV,EAASV,IACZmB,GACR,IAEP,OAAOT,EAAUS,GACb,MAAMrB,EAAOV,KAAKW,WAClB,IAAIC,EAAMF,IACV,KAAOE,GACHmB,EAAOT,EAASS,EAAMnB,GACtBA,EAAMF,IAEV,OAAOqB,IC1KA,MAAME,UAAuBC,MACxC,YAAYC,GAERC,MADAD,EAAU,eAAiBA,GAE3BnC,KAAKmC,QAAUA,EACfnC,KAAK1B,KAAO0B,KAAKqC,YAAY/D,MCHtB,MAAM,EACjB,cACI0B,KAAKsC,WAAa,GAClBtC,KAAKuC,QAAU,GACfvC,KAAKwC,KAAO,GACZxC,KAAKyC,MAAQ,GAEjB,YAAY5B,EAAM6B,GAAS,GACvB,OAAY,MAAR7B,EACO,KAEPb,KAAK2C,MAAMC,IAAI/B,GACRb,KAAK2C,MAAM/D,IAAIiC,IAAS,KAE/B6B,EACO1C,KAAKyB,KAAKZ,EAAKgC,WAAYH,GAE/B,KAEX,OAAOI,EAAQC,EAAO/D,GAClB,MAAMgE,EAAQhD,KAAKiD,MAAMF,GACzB,GAAa,MAATC,EACA,MAAM,IAAIf,EAAe,oBAAoBc,UAEjD,MAAMG,EAAYF,EACZnC,EAENkC,aAAiBI,MAAQJ,EAAMK,WAAaD,KAAKE,UAC3CN,EACAG,EAAU7D,OAAOL,GACjBsE,EAAO,IAAIJ,EAAUJ,EAAQjC,EAAM7B,GAEzC,OADA,EAAS2D,MAAMY,IAAID,EAAKE,QAASF,GAC1BA,EAEX,KAAKzC,EAAM6B,GAAS,GAChB,OAAO,EAASjB,KAAKZ,EAAM6B,GAE/B,MAAMO,EAAOQ,EAAQ,EAAMC,KACvB,IAAIV,EACJ,GAAqB,iBAAVC,EACPD,EAAQhD,KAAKyC,MAAMQ,IAAUjD,KAAKsC,WAAWW,QAG5C,GAAIA,aAAiBU,MAAQV,EAAMG,WAAaD,KAAKE,UACtDL,EAAQhD,KAAKyC,MAAMmB,UAElB,GAAqB,iBAAVX,EACRA,EAAQ,EAAMY,MAAQ,EAAMC,MAC5Bd,EAAQhD,KAAKyC,MAAMsB,MAEdd,EAAQ,EAAMY,MAAQ,EAAMG,SACjChB,EAAQhD,KAAKyC,MAAMwB,aAGtB,GAAIhB,aAAiBiB,YAAa,EACpBjB,EAAMkB,aAAa,UAAY,IAAIC,MAAM,OAClDC,KAAM/F,IACR0E,EAAQhD,KAAKuC,QAAQjE,KACjB0E,IAKRA,EAAQA,GAAShD,KAAKwC,KAAKS,EAAMqB,SAErC,OAAa,MAATtB,EACO,KAGPS,EAAQ,EAAMI,MAAQb,EAAMS,OAASA,EAAQ,EAAMc,KAAOvB,EAAMS,MACzDT,EAEJ,KAEX,YAAYwB,GACR,GAAIA,EAAYrE,OAAS,EACrB,OAAOqE,EAAYC,IAAKpG,GACb2B,KAAK0E,SAASrG,IAG7B,MAAMsG,EAAaH,EAAY,GAC/B,GAAmC,iBAAxBG,EAAWC,UACa,iBAAxBD,EAAWE,SAClB,MAAM,IAAI5C,EAAe,sBAExB,GAA4B,aAAxB0C,EAAWC,SAChB,MAAM,IAAI3C,EAAe,kCAG7B,GADAjC,KAAKyC,MAAMkC,EAAWC,UAAYD,EAAWE,UAAYF,EACvB,iBAAvBA,EAAWG,QAClB9E,KAAKsC,WAAWqC,EAAWG,SAAWH,OAMtC,GAH4B,MAAxBA,EAAWI,YACX/E,KAAKuC,QAAQoC,EAAWI,WAAaJ,GAEf,MAAtBA,EAAWL,QAAiB,CACxBU,MAAMC,QAAQN,EAAWL,SACzBK,EAAWL,QAAUK,EAAWL,QAAQG,IAAKH,GAClCA,EAAQY,eAInBP,EAAWL,QAAUK,EAAWL,QAAQY,eAE3BF,MAAMC,QAAQN,EAAWL,SACpCK,EAAWL,QACX,CAACK,EAAWL,UACTa,QAASC,IACQ,MAAlBpF,KAAKwC,KAAK4C,IAAwC,MAAxBT,EAAWI,YACrC/E,KAAKwC,KAAK4C,GAAOT,KAKjC,OAAOA,GAGf,EAAShC,MAAQ,IAAI0C,QCrHrB,MAAM,EACF,YAAYvC,EAAQU,GAChBxD,KAAK8C,OAASA,EACd9C,KAAKwD,QAAUA,EACf,EAASb,MAAMY,IAAIC,EAASxD,MAC5BA,KAAKgB,KAAO,KACZhB,KAAKU,KAAO,KAEhB,cAAc1B,GACV,GAAoB,MAAhBgB,KAAKsE,QACL,MAAM,IAAIrC,EAAe,mCAE7B,IAAIpB,EAwBJ,OAvBImE,MAAMC,QAAQjF,KAAKsE,UACE,iBAAVtF,IACPA,EAAQA,EAAMkG,cACVI,SAAStG,EAAO,IAAIuG,aAAevG,IACnCA,EAAQsG,SAAStG,EAAO,MAI5B6B,EADiB,iBAAV7B,EACAwG,SAASC,cAAczF,KAAKsE,QAAQtF,EAAQ,IAE9CgB,KAAKsE,QAAQoB,QAAQ1G,IAAU,EAC7BwG,SAASC,cAAczG,GAGvBwG,SAASC,cAAczF,KAAKsE,QAAQ,KAI/CzD,EAAO2E,SAASC,cAAczF,KAAKsE,SAEnCtE,KAAK+E,WACLlE,EAAK8E,UAAUC,IAAI5F,KAAK+E,WAErBlE,EAGX,cACI,OAAOb,KAAKqC,YAEhB,UAGA,QACI,MAAMmB,EAAUxD,KAAKwD,QAAQqC,WAAU,GACvC,OAAO7F,KAAK8C,OAAOzD,OAAOmE,GAE9B,SACuB,MAAfxD,KAAK8F,QACL9F,KAAK8F,OAAOC,YAAY/F,MAE5B,EAAS2C,MAAMqD,OAAOhG,KAAKwD,SAE/B,SAAS/C,EAAON,GACCH,KAAKiG,QAAQxF,EAAON,GAC5BY,SAET,SAASN,EAAON,EAAQ7B,EAAMU,GAC1B,MAAMsE,EAAOtD,KAAKiG,QAAQxF,EAAON,GACjC,GAA2C,MAAvCH,KAAK8C,OAAOG,MAAM3E,EAAM,EAAM4H,OAAiBlH,EAC/CsE,EAAK6C,KAAK7H,EAAMU,QAEf,GAAgD,MAA5CgB,KAAK8C,OAAOG,MAAM3E,EAAM,EAAM8H,WAAoB,CACvD,MAAMN,EAAS9F,KAAK8C,OAAOzD,OAAOW,KAAKqG,QAAQ5C,OAC/CH,EAAK6C,KAAKL,GACVA,EAAOQ,OAAOhI,EAAMU,IAG5B,SAASyB,EAAOzB,EAAOuH,GACnB,MAAMjD,EAAc,MAAPiD,EACPvG,KAAK8C,OAAOzD,OAAO,OAAQL,GAC3BgB,KAAK8C,OAAOzD,OAAOL,EAAOuH,GAC1BC,EAAMxG,KAAKoE,MAAM3D,GACvBT,KAAK8F,OAAOzF,aAAaiD,EAAMkD,QAAOC,GAE1C,QAAQhG,EAAON,GACX,MAAMc,EAASjB,KAAKoE,MAAM3D,GAC1B,GAAc,MAAVQ,EACA,MAAM,IAAIiB,MAAM,6BAGpB,OADAjB,EAAOmD,MAAMjE,GACNc,EAEX,SACI,OAAO,EAEX,OAAO5D,EAAO2C,KAAK8F,QACf,OAAmB,MAAf9F,KAAK8F,QAAkB9F,OAAS3C,EACzB,EAEJ2C,KAAK8F,OAAOY,SAASlF,OAAOxB,MAAQA,KAAK8F,OAAOtE,OAAOnE,GAElE,SAASsJ,IACD3G,KAAKqG,QAAQO,mBACX5G,KAAK8F,kBAAkB9F,KAAKqG,QAAQO,mBACtC5G,KAAKmG,KAAKnG,KAAKqG,QAAQO,kBAAkBhC,UAGjD,SACmC,MAA3B5E,KAAKwD,QAAQX,YACb7C,KAAKwD,QAAQX,WAAWkD,YAAY/F,KAAKwD,SAE7CxD,KAAK6G,SAET,YAAYvI,EAAMU,GACd,MAAM8H,EAA8B,iBAATxI,EAAoB0B,KAAK8C,OAAOzD,OAAOf,EAAMU,GAASV,EAKjF,OAJmB,MAAf0B,KAAK8F,SACL9F,KAAK8F,OAAOzF,aAAayG,EAAa9G,KAAKU,WAAQ+F,GACnDzG,KAAKe,UAEF+F,EAEX,MAAMrG,EAAOsG,GACT,OAAiB,IAAVtG,EAAcT,KAAOA,KAAKU,KAErC,OAAOsG,EAAYL,IAGnB,KAAKrI,EAAMU,GACP,MAAMiI,EAA0B,iBAAT3I,EACjB0B,KAAK8C,OAAOzD,OAAOf,EAAMU,GACzBV,EAIN,GAHmB,MAAf0B,KAAK8F,QACL9F,KAAK8F,OAAOzF,aAAa4G,EAASjH,KAAKU,WAAQ+F,GAEhB,mBAAxBQ,EAAQC,YACf,MAAM,IAAIjF,EAAe,eAAe3D,KAG5C,OADA2I,EAAQC,YAAYlH,MACbiH,GAGf,EAAWrC,SAAW,WACP,QCtIf,SAASuC,EAAiBtG,EAAMiC,GAC5B,IAAIQ,EAAOR,EAAOrB,KAAKZ,GACvB,GAAY,MAARyC,EACA,IACIA,EAAOR,EAAOzD,OAAOwB,GAEzB,MAAOuG,GACH9D,EAAOR,EAAOzD,OAAO,EAAM2E,QAC3BgB,MAAMqC,KAAKxG,EAAKyG,YAAYnC,QAASoC,IAEjCjE,EAAKE,QAAQ0D,YAAYK,KAEzB1G,EAAKgC,YACLhC,EAAKgC,WAAW2E,aAAalE,EAAKE,QAAS3C,GAE/CyC,EAAKmE,SAGb,OAAOnE,EAEX,MAAM,UAAmB,EACrB,YAAYR,EAAQU,GAChBpB,MAAMU,EAAQU,GACdxD,KAAK0H,OAAS,KACd1H,KAAK2H,QAET,YAAYC,GACR5H,KAAKK,aAAauH,GAEtB,SACIxF,MAAMqF,SACNzH,KAAK0G,SAASvB,QAASoC,IACnBA,EAAME,WAGd,SAAS5G,GACc,MAAfb,KAAK0H,QACL1H,KAAK0H,OAAO3G,SAEhBf,KAAK0H,OAAS7G,EACV,EAAWgH,SACX7H,KAAK0H,OAAO/B,UAAUC,IAAI,EAAWiC,SAEzC7H,KAAK0H,OAAOI,aAAa,kBAAmB,SAC5C9H,KAAKwD,QAAQnD,aAAaL,KAAK0H,OAAQ1H,KAAKwD,QAAQuE,YAExD,QACI/H,KAAK0G,SAAW,IAAI,EAEpB1B,MAAMqC,KAAKrH,KAAKwD,QAAQ8D,YACnBU,OAAQnH,GAASA,IAASb,KAAK0H,QAC/BO,UACA9C,QAAStE,IACV,IACI,MAAM0G,EAAQJ,EAAiBtG,EAAMb,KAAK8C,QAC1C9C,KAAKK,aAAakH,EAAOvH,KAAK0G,SAASzG,WAAQwG,GAEnD,MAAOyB,GACH,GAAIA,aAAejG,EACf,OAGA,MAAMiG,KAKtB,SAASzH,EAAON,GACZ,GAAc,IAAVM,GAAeN,IAAWH,KAAKG,SAC/B,OAAOH,KAAKe,SAEhBf,KAAK0G,SAASyB,UAAU1H,EAAON,EAAQ,CAACoH,EAAO/F,EAAQ4G,KACnDb,EAAMc,SAAS7G,EAAQ4G,KAG/B,WAAWE,EAAU7H,EAAQ,GACzB,MAAO8G,EAAO/F,GAAUxB,KAAK0G,SAASjF,KAAKhB,GAC3C,OAA0B,MAArB6H,EAAS1D,UAAoB0D,EAASf,IACjB,MAArBe,EAAS1D,UAAoB2C,aAAiBe,EACxC,CAACf,EAAO/F,GAEV+F,aAAiB,EACfA,EAAMgB,WAAWD,EAAU9G,GAG3B,CAAC,MAAO,GAGvB,YAAY8G,EAAU7H,EAAQ,EAAGN,EAASqI,OAAOC,WAC7C,IAAIC,EAAc,GACdC,EAAaxI,EAWjB,OAVAH,KAAK0G,SAASyB,UAAU1H,EAAON,EAAQ,CAACoH,EAAOqB,EAAYR,MAC7B,MAArBE,EAAS1D,UAAoB0D,EAASf,IACjB,MAArBe,EAAS1D,UAAoB2C,aAAiBe,IAC/CI,EAAY1G,KAAKuF,GAEjBA,aAAiB,IACjBmB,EAAcA,EAAYG,OAAOtB,EAAMmB,YAAYJ,EAAUM,EAAYD,KAE7EA,GAAcP,IAEXM,EAEX,SACI1I,KAAK0G,SAASvB,QAASoC,IACnBA,EAAMV,WAEVzE,MAAMyE,SAEV,yBACI,IAAIiC,GAAO,EACX9I,KAAK0G,SAASvB,QAASoC,IACnB,GAAIuB,EACA,OAEY9I,KAAKqG,QAAQ0C,gBAAgB1E,KAAMkC,GAAQgB,aAAiBhB,KAIxEgB,EAAMlB,QAAQ5C,QAAU,EAAMuF,YACZ,MAAdzB,EAAM7G,MACNV,KAAKiJ,WAAW1B,GAEF,MAAdA,EAAMvG,MACNhB,KAAKiJ,WAAW1B,EAAMvG,MAE1BuG,EAAMzB,OAAOoD,SACbJ,GAAO,GAEFvB,aAAiB,EACtBA,EAAM2B,SAGN3B,EAAMxG,YAIlB,SAASN,EAAON,EAAQ7B,EAAMU,GAC1BgB,KAAK0G,SAASyB,UAAU1H,EAAON,EAAQ,CAACoH,EAAO/F,EAAQ4G,KACnDb,EAAM4B,SAAS3H,EAAQ4G,EAAa9J,EAAMU,KAGlD,SAASyB,EAAOzB,EAAOuH,GACnB,MAAOgB,EAAO/F,GAAUxB,KAAK0G,SAASjF,KAAKhB,GAC3C,GAAI8G,EACAA,EAAM6B,SAAS5H,EAAQxC,EAAOuH,OAE7B,CACD,MAAMjD,EAAc,MAAPiD,EACPvG,KAAK8C,OAAOzD,OAAO,OAAQL,GAC3BgB,KAAK8C,OAAOzD,OAAOL,EAAOuH,GAChCvG,KAAKkH,YAAY5D,IAGzB,aAAa+F,EAAWC,GACI,MAApBD,EAAUvD,QACVuD,EAAUvD,OAAOY,SAAS3F,OAAOsI,GAErC,IAAIE,EAAa,KACjBvJ,KAAK0G,SAASrG,aAAagJ,EAAWC,GAAW,MACjDD,EAAUvD,OAAS9F,KACJ,MAAXsJ,IACAC,EAAaD,EAAQ9F,SAErBxD,KAAKwD,QAAQX,aAAewG,EAAU7F,SACtCxD,KAAKwD,QAAQgG,cAAgBD,GAC7BvJ,KAAKwD,QAAQnD,aAAagJ,EAAU7F,QAAS+F,GAEjDF,EAAU5B,SAEd,SACI,OAAOzH,KAAK0G,SAAS5E,OAAO,CAACC,EAAMwF,IACxBxF,EAAOwF,EAAMpH,SACrB,GAEP,aAAasJ,EAAc3I,GACvBd,KAAK0G,SAASvB,QAASoC,IACnBkC,EAAapJ,aAAakH,EAAOzG,KAGzC,SAAS4I,GAML,GALAtH,MAAMuH,SAASD,GACf1J,KAAK4J,yBACc,MAAf5J,KAAK0H,QAAkB1H,KAAK0H,SAAW1H,KAAKwD,QAAQuE,YACpD/H,KAAKwD,QAAQnD,aAAaL,KAAK0H,OAAQ1H,KAAKwD,QAAQuE,YAE3B,IAAzB/H,KAAK0G,SAASvG,OACd,GAAiC,MAA7BH,KAAKqG,QAAQwD,aAAsB,CACnC,MAAMtC,EAAQvH,KAAK8C,OAAOzD,OAAOW,KAAKqG,QAAQwD,aAAajF,UAC3D5E,KAAKkH,YAAYK,QAKjBvH,KAAKe,SAIjB,KAAKN,EAAOY,GAAY,GACpB,MAAOkG,EAAO/F,GAAUxB,KAAK0G,SAASjF,KAAKhB,EAAOY,GAC5CyI,EAAW,CAAC,CAAC9J,KAAMS,IACzB,OAAI8G,aAAiB,EACVuC,EAASjB,OAAOtB,EAAMwC,KAAKvI,EAAQH,KAE5B,MAATkG,GACLuC,EAAS9H,KAAK,CAACuF,EAAO/F,IAEnBsI,GAEX,YAAYvC,GACRvH,KAAK0G,SAAS3F,OAAOwG,GAEzB,YAAYjJ,EAAMU,GACd,MAAM8H,EAA8B,iBAATxI,EAAoB0B,KAAK8C,OAAOzD,OAAOf,EAAMU,GAASV,EAIjF,OAHIwI,aAAuB,GACvB9G,KAAKgK,aAAalD,GAEf1E,MAAM6H,YAAYnD,GAE7B,MAAMrG,EAAOyJ,GAAQ,GACjB,IAAKA,EAAO,CACR,GAAc,IAAVzJ,EACA,OAAOT,KAEX,GAAIS,IAAUT,KAAKG,SACf,OAAOH,KAAKU,KAGpB,MAAMyJ,EAAQnK,KAAKoK,QAUnB,OATIpK,KAAK8F,QACL9F,KAAK8F,OAAOzF,aAAa8J,EAAOnK,KAAKU,WAAQ+F,GAEjDzG,KAAK0G,SAASyB,UAAU1H,EAAOT,KAAKG,SAAU,CAACoH,EAAO/F,EAAQ6I,KAC1D,MAAMjG,EAAQmD,EAAMnD,MAAM5C,EAAQ0I,GACrB,MAAT9F,GACA+F,EAAMjD,YAAY9C,KAGnB+F,EAEX,WAAW5C,GACP,MAAM4C,EAAQnK,KAAKoK,QACnB,KAAqB,MAAd7C,EAAM7G,MACTyJ,EAAMjD,YAAYK,EAAM7G,MAK5B,OAHIV,KAAK8F,QACL9F,KAAK8F,OAAOzF,aAAa8J,EAAOnK,KAAKU,WAAQ+F,GAE1C0D,EAEX,SACQnK,KAAK8F,QACL9F,KAAKgK,aAAahK,KAAK8F,OAAQ9F,KAAKU,WAAQ+F,GAEhDzG,KAAKe,SAET,OAAOuJ,EAAW3D,GACd,MAAM4D,EAAa,GACbC,EAAe,GACrBF,EAAUnF,QAASsF,IACXA,EAASxJ,SAAWjB,KAAKwD,SAA6B,cAAlBiH,EAASC,OAC7CH,EAAWvI,QAAQyI,EAASF,YAC5BC,EAAaxI,QAAQyI,EAASD,iBAGtCA,EAAarF,QAAStE,IAIlB,GAAuB,MAAnBA,EAAKgC,YAEY,WAAjBhC,EAAKyD,SACLkB,SAASmF,KAAKC,wBAAwB/J,GAClCsC,KAAK0H,+BACT,OAEJ,MAAMvH,EAAOtD,KAAK8C,OAAOrB,KAAKZ,GAClB,MAARyC,IAG2B,MAA3BA,EAAKE,QAAQX,YACbS,EAAKE,QAAQX,aAAe7C,KAAKwD,SACjCF,EAAKuD,YAGb0D,EACKvC,OAAQnH,GACFA,EAAKgC,aAAe7C,KAAKwD,SAAW3C,IAASb,KAAK0H,QAExDoD,KAAK,CAACC,EAAGC,IACND,IAAMC,EACC,EAEPD,EAAEH,wBAAwBI,GAAK7H,KAAK8H,4BAC7B,GAEH,GAEP9F,QAAStE,IACV,IAAIyI,EAAU,KACU,MAApBzI,EAAK2I,cACLF,EAAUtJ,KAAK8C,OAAOrB,KAAKZ,EAAK2I,cAEpC,MAAMlG,EAAO6D,EAAiBtG,EAAMb,KAAK8C,QACrCQ,EAAK5C,OAAS4I,GAAwB,MAAbhG,EAAK5C,OACX,MAAf4C,EAAKwC,QACLxC,EAAKwC,OAAOC,YAAY/F,MAE5BA,KAAKK,aAAaiD,EAAMgG,QAAW7C,MAG3CzG,KAAK4J,0BAGb,EAAW/B,QAAU,GACN,QC7Tf,MAAM,UAAsB,EACxB,aACI,OAAsB,OAAd7H,KAAKU,MAAiBV,KAAKU,KAAK2F,QAAQzB,WAAa5E,KAAKqG,QAAQzB,SAE9E,SAASnE,EAAON,GACZiC,MAAMiG,SAAS5H,EAAON,GACtBH,KAAK4J,yBAET,SAASnJ,EAAON,EAAQ7B,EAAMU,GAC1BoD,MAAM+G,SAAS1I,EAAON,EAAQ7B,EAAMU,GACpCgB,KAAK4J,yBAET,SAASnJ,EAAOzB,EAAOuH,GACnBnE,MAAMgH,SAAS3I,EAAOzB,EAAOuH,GAC7BvG,KAAK4J,yBAET,SAASF,GACLtH,MAAMuH,SAASD,GACX1J,KAAK0G,SAASvG,OAAS,GAAkB,MAAbH,KAAKU,MAAgBV,KAAKkL,eACtDlL,KAAKU,KAAKsJ,aAAahK,MACvBA,KAAKU,KAAKK,WAItB,EAAc6D,SAAW,YACzB,EAAcnB,MAAQ,EAAMuF,WACb,QC1Bf,MAAM,UAAiB,EACnB,aAAamC,GACT,OAAO,EAEX,MAAMtK,EAAMW,GACR,OAAIxB,KAAKwD,UAAY3C,GACjBb,KAAKwD,QAAQoH,wBAAwB/J,GACjCsC,KAAK0H,+BACFjJ,KAAKC,IAAIL,EAAQ,IAEpB,EAEZ,SAASf,EAAO2K,GAEZ,IAAI5J,EADewD,MAAMqC,KAAKrH,KAAK8F,OAAOtC,QAAQ8D,YAC1B5B,QAAQ1F,KAAKwD,SAIrC,OAHI/C,EAAQ,IACRe,GAAU,GAEP,CAACxB,KAAK8F,OAAOtC,QAAShC,GAEjC,QACI,MAAO,CACH,CAACxB,KAAKqG,QAAQzB,UAAW5E,KAAKqG,QAAQrH,MAAMgB,KAAKwD,WAAY,IAIzE,EAASC,MAAQ,EAAM4H,YACR,QC5BA,MAAM,EACjB,YAAYxG,EAAUC,EAASwG,EAAU,IACrCtL,KAAK6E,SAAWA,EAChB7E,KAAK8E,QAAUA,EACf,MAAMyG,EAAe,EAAMhH,KAAO,EAAM6B,UACxCpG,KAAKyD,MACgB,MAAjB6H,EAAQ7H,MAEC6H,EAAQ7H,MAAQ,EAAMI,MAAS0H,EAClC,EAAMnF,UACS,MAArBkF,EAAQE,YACRxL,KAAKwL,UAAYF,EAAQE,WAGjC,YAAY3K,GACR,OAAOmE,MAAMqC,KAAKxG,EAAKyB,YAAYmC,IAAKgH,GAASA,EAAKnN,MAE1D,IAAIuC,EAAM7B,GACN,QAAKgB,KAAK0L,OAAO7K,EAAM7B,KAGvB6B,EAAKiH,aAAa9H,KAAK8E,QAAS9F,IACzB,GAEX,OAAO2M,EAAO3M,GACV,OAAsB,MAAlBgB,KAAKwL,YAGY,iBAAVxM,EACAgB,KAAKwL,UAAU9F,QAAQ1G,EAAM4M,QAAQ,QAAS,MAAQ,EAGtD5L,KAAKwL,UAAU9F,QAAQ1G,IAAU,GAGhD,OAAO6B,GACHA,EAAKgL,gBAAgB7L,KAAK8E,SAE9B,MAAMjE,GACF,MAAM7B,EAAQ6B,EAAKsD,aAAanE,KAAK8E,SACrC,OAAI9E,KAAK0L,OAAO7K,EAAM7B,IAAUA,EACrBA,EAEJ,IC3Cf,SAAS,EAAM6B,EAAMiL,GAEjB,OADkBjL,EAAKsD,aAAa,UAAY,IAE3CC,MAAM,OACN4D,OAAQ1J,GAAwC,IAA/BA,EAAKoH,QAAQ,GAAGoG,OA+B3B,MA7Bf,cAA8B,EAC1B,YAAYjL,GACR,OAAQA,EAAKsD,aAAa,UAAY,IACjCC,MAAM,OACNK,IAAKnG,GAASA,EAAK8F,MAAM,KAAK7D,MAAM,GAAI,GAAGwL,KAAK,MAEzD,IAAIlL,EAAM7B,GACN,QAAKgB,KAAK0L,OAAO7K,EAAM7B,KAGvBgB,KAAKe,OAAOF,GACZA,EAAK8E,UAAUC,IAAI,GAAG5F,KAAK8E,WAAW9F,MAC/B,GAEX,OAAO6B,GACa,EAAMA,EAAMb,KAAK8E,SACzBK,QAAS7G,IACbuC,EAAK8E,UAAU5E,OAAOzC,KAEI,IAA1BuC,EAAK8E,UAAUxF,QACfU,EAAKgL,gBAAgB,SAG7B,MAAMhL,GACF,MACM7B,GADS,EAAM6B,EAAMb,KAAK8E,SAAS,IAAM,IAC1BvE,MAAMP,KAAK8E,QAAQ3E,OAAS,GACjD,OAAOH,KAAK0L,OAAO7K,EAAM7B,GAASA,EAAQ,KChClD,SAASgN,EAAS1N,GACd,MAAM2N,EAAQ3N,EAAK8F,MAAM,KACnB9D,EAAO2L,EACR1L,MAAM,GACNkE,IAAKyH,GAASA,EAAK,GAAGhH,cAAgBgH,EAAK3L,MAAM,IACjDwL,KAAK,IACV,OAAOE,EAAM,GAAK3L,EA8BP,MA5Bf,cAA8B,EAC1B,YAAYO,GACR,OAAQA,EAAKsD,aAAa,UAAY,IAAIC,MAAM,KAAKK,IAAKzF,GAC1CA,EAAMoF,MAAM,KACb,GAAG+H,QAGtB,IAAItL,EAAM7B,GACN,QAAKgB,KAAK0L,OAAO7K,EAAM7B,KAIvB6B,EAAKuL,MAAMJ,EAAShM,KAAK8E,UAAY9F,GAC9B,GAEX,OAAO6B,GAEHA,EAAKuL,MAAMJ,EAAShM,KAAK8E,UAAY,GAChCjE,EAAKsD,aAAa,UACnBtD,EAAKgL,gBAAgB,SAG7B,MAAMhL,GAEF,MAAM7B,EAAQ6B,EAAKuL,MAAMJ,EAAShM,KAAK8E,UACvC,OAAO9E,KAAK0L,OAAO7K,EAAM7B,GAASA,EAAQ,KCiCnC,MA9Df,MACI,YAAYwE,GACRxD,KAAKsC,WAAa,GAClBtC,KAAKwD,QAAUA,EACfxD,KAAK2H,QAET,UAAU0E,EAAWrN,GAEbA,EACIqN,EAAUzG,IAAI5F,KAAKwD,QAASxE,KACS,MAAjCqN,EAAUrN,MAAMgB,KAAKwD,SACrBxD,KAAKsC,WAAW+J,EAAUxH,UAAYwH,SAG/BrM,KAAKsC,WAAW+J,EAAUxH,YAKzCwH,EAAUtL,OAAOf,KAAKwD,gBACfxD,KAAKsC,WAAW+J,EAAUxH,WAGzC,QACI7E,KAAKsC,WAAa,GAClB,MAAMgB,EAAO,EAAS7B,KAAKzB,KAAKwD,SAChC,GAAY,MAARF,EACA,OAEJ,MAAMhB,EAAa,EAAWgK,KAAKtM,KAAKwD,SAClCjB,EAAU,EAAgB+J,KAAKtM,KAAKwD,SACpC+I,EAAS,EAAgBD,KAAKtM,KAAKwD,SACzClB,EACKuG,OAAOtG,GACPsG,OAAO0D,GACPpH,QAAS7G,IACV,MAAMkO,EAAOlJ,EAAKR,OAAOG,MAAM3E,EAAM,EAAM8H,WACvCoG,aAAgB,IAChBxM,KAAKsC,WAAWkK,EAAK3H,UAAY2H,KAI7C,KAAKvL,GACDxC,OAAO6N,KAAKtM,KAAKsC,YAAY6C,QAAS7F,IAClC,MAAMN,EAAQgB,KAAKsC,WAAWhD,GAAKN,MAAMgB,KAAKwD,SAC9CvC,EAAOqF,OAAOhH,EAAKN,KAG3B,KAAKiC,GACDjB,KAAKyM,KAAKxL,GACVxC,OAAO6N,KAAKtM,KAAKsC,YAAY6C,QAAS7F,IAClCU,KAAKsC,WAAWhD,GAAKyB,OAAOf,KAAKwD,WAErCxD,KAAKsC,WAAa,GAEtB,SACI,OAAO7D,OAAO6N,KAAKtM,KAAKsC,YAAYR,OAAO,CAACQ,EAAYhE,KACpDgE,EAAWhE,GAAQ0B,KAAKsC,WAAWhE,GAAMU,MAAMgB,KAAKwD,SAC7ClB,GACR,MC7CX,MAAM,UAAmB,EACrB,YAAYQ,EAAQU,GAChBpB,MAAMU,EAAQU,GACdxD,KAAKsC,WAAa,IAAI,EAAgBtC,KAAKwD,SAE/C,eAAeA,EAASV,GACpB,MAAME,EAAQF,EAAOG,MAAM,EAAW2B,UACtC,GAAa,MAAT5B,GACAQ,EAAQc,UAAYtB,EAAMsB,QAGzB,MAA4B,iBAAjBtE,KAAKsE,UAGZU,MAAMC,QAAQjF,KAAKsE,SACjBd,EAAQc,QAAQoI,mBADtB,GAKT,OAAOpO,EAAMU,GACT,GAAIV,IAAS0B,KAAKqG,QAAQzB,UAAa5F,EASlC,CACD,MAAMsH,EAAStG,KAAK8C,OAAOG,MAAM3E,EAAM,EAAM0F,QAC7C,GAAc,MAAVsC,EACA,OAEAA,aAAkB,EAClBtG,KAAKsC,WAAW+J,UAAU/F,EAAQtH,IAE7BA,GACJV,IAAS0B,KAAKqG,QAAQzB,UAAY5E,KAAK2M,UAAUrO,KAAUU,GAC5DgB,KAAKiK,YAAY3L,EAAMU,QAlB3BgB,KAAK0G,SAASvB,QAASoC,IACbA,aAAiB,IACnBA,EAAQA,EAAMpB,KAAK,EAAWvB,UAAU,IAE5C5E,KAAKsC,WAAWmK,KAAKlF,KAEzBvH,KAAKkJ,SAgBb,UACI,MAAMyD,EAAU3M,KAAKsC,WAAWsK,SAC1BtG,EAAStG,KAAKqG,QAAQsG,QAAQ3M,KAAKwD,QAASxD,KAAK8C,QAIvD,OAHc,MAAVwD,IACAqG,EAAQ3M,KAAKqG,QAAQzB,UAAY0B,GAE9BqG,EAEX,SAASlM,EAAON,EAAQ7B,EAAMU,GAC1B,GAA4B,MAAxBgB,KAAK2M,UAAUrO,IACf0B,KAAK8C,OAAOG,MAAM3E,EAAM,EAAM8H,WAAY,CAC7BpG,KAAKiG,QAAQxF,EAAON,GAC5BmG,OAAOhI,EAAMU,QAGlBoD,MAAM+G,SAAS1I,EAAON,EAAQ7B,EAAMU,GAG5C,SAAS0K,GACLtH,MAAMuH,SAASD,GACf,MAAMiD,EAAU3M,KAAK2M,UACrB,GAAoC,IAAhClO,OAAO6N,KAAKK,GAASxM,OACrB,OAAOH,KAAKkJ,SAEhB,MAAMxI,EAAOV,KAAKU,KACdA,aAAgB,GAChBA,EAAKM,OAAShB,MAlF1B,SAAiB6M,EAAMC,GACnB,GAAIrO,OAAO6N,KAAKO,GAAM1M,SAAW1B,OAAO6N,KAAKQ,GAAM3M,OAC/C,OAAO,EAGX,IAAK,MAAM4M,KAAQF,EAEf,GAAIA,EAAKE,KAAUD,EAAKC,GACpB,OAAO,EAGf,OAAO,EAwECC,CAAQL,EAASjM,EAAKiM,aACtBjM,EAAKsJ,aAAahK,MAClBU,EAAKK,UAGb,YAAYzC,EAAMU,GACd,MAAM8H,EAAc1E,MAAM6H,YAAY3L,EAAMU,GAE5C,OADAgB,KAAKsC,WAAWmK,KAAK3F,GACdA,EAEX,OAAOwD,EAAWZ,GACdtH,MAAM6K,OAAO3C,EAAWZ,GACCY,EAAUjG,KAAMoG,GAAaA,EAASxJ,SAAWjB,KAAKwD,SAA6B,eAAlBiH,EAASC,OAE/F1K,KAAKsC,WAAWqF,QAGxB,KAAKrJ,EAAMU,GACP,MAAMiI,EAAU7E,MAAM+D,KAAK7H,EAAMU,GAIjC,OAHIiI,aAAmB,GACnBjH,KAAKsC,WAAW4K,KAAKjG,GAElBA,GAGf,EAAW8B,gBAAkB,CAAC,EAAY,GAC1C,EAAWnE,SAAW,SACtB,EAAWnB,MAAQ,EAAM4H,YACzB,EAAW/G,QAAU,OACN,QChHf,MAAM,UAAkB,EACpB,YAAYxB,EAAQU,GAChBpB,MAAMU,EAAQU,GACdxD,KAAKsC,WAAa,IAAI,EAAgBtC,KAAKwD,SAE/C,eAAeA,EAASV,GACpB,MAAME,EAAQF,EAAOG,MAAM,EAAU2B,UACrC,GAAa,MAAT5B,GACAQ,EAAQc,UAAYtB,EAAMsB,QAGzB,MAA4B,iBAAjBtE,KAAKsE,UAGZU,MAAMC,QAAQjF,KAAKsE,SACjBd,EAAQc,QAAQoI,mBADtB,GAIT,OAAOpO,EAAMU,GACT,MAAMsH,EAAStG,KAAK8C,OAAOG,MAAM3E,EAAM,EAAMwF,OAC/B,MAAVwC,IAGKA,aAAkB,EACvBtG,KAAKsC,WAAW+J,UAAU/F,EAAQtH,GAE7BV,IAAS0B,KAAKqG,QAAQzB,UAAa5F,GAGnCA,GACJV,IAAS0B,KAAKqG,QAAQzB,UAAY5E,KAAK2M,UAAUrO,KAAUU,GAC5DgB,KAAKiK,YAAY3L,EAAMU,GAJvBgB,KAAKiK,YAAY,EAAUrF,WAOnC,UACI,MAAM+H,EAAU3M,KAAKsC,WAAWsK,SAC1BtG,EAAStG,KAAKqG,QAAQsG,QAAQ3M,KAAKwD,QAASxD,KAAK8C,QAIvD,OAHc,MAAVwD,IACAqG,EAAQ3M,KAAKqG,QAAQzB,UAAY0B,GAE9BqG,EAEX,SAASlM,EAAON,EAAQ7B,EAAMU,GACkB,MAAxCgB,KAAK8C,OAAOG,MAAM3E,EAAM,EAAMwF,OAC9B9D,KAAKsG,OAAOhI,EAAMU,GAGlBoD,MAAM+G,SAAS1I,EAAON,EAAQ7B,EAAMU,GAG5C,SAASyB,EAAOzB,EAAOuH,GACnB,GAAW,MAAPA,GAAyD,MAA1CvG,KAAK8C,OAAOG,MAAMjE,EAAO,EAAMgF,QAE9C5B,MAAMgH,SAAS3I,EAAOzB,EAAOuH,OAE5B,CACD,MAAM4D,EAAQnK,KAAKoE,MAAM3D,GACzB,GAAa,MAAT0J,EAKA,MAAM,IAAIjI,MAAM,8CALD,CACf,MAAMoB,EAAOtD,KAAK8C,OAAOzD,OAAOL,EAAOuH,GACvC4D,EAAMrE,OAAOzF,aAAaiD,EAAM6G,KAO5C,YAAY7L,EAAMU,GACd,MAAM8H,EAAc1E,MAAM6H,YAAY3L,EAAMU,GAE5C,OADAgB,KAAKsC,WAAWmK,KAAK3F,GACdA,EAEX,OAAOwD,EAAWZ,GACdtH,MAAM6K,OAAO3C,EAAWZ,GACCY,EAAUjG,KAAMoG,GAAaA,EAASxJ,SAAWjB,KAAKwD,SAA6B,eAAlBiH,EAASC,OAE/F1K,KAAKsC,WAAWqF,SAI5B,EAAU/C,SAAW,QACrB,EAAUnB,MAAQ,EAAMuF,WACxB,EAAU1E,QAAU,IACpB,EAAUyE,gBAAkB,CACxB,EACA,EACA,GAEW,QCtEA,MAtBf,cAAwB,EACpB,eAAeoC,EAAUgC,IAGzB,OAAO7O,EAAMU,GAIToD,MAAM+G,SAAS,EAAGnJ,KAAKG,SAAU7B,EAAMU,GAE3C,SAASyB,EAAON,EAAQ7B,EAAMU,GACZ,IAAVyB,GAAeN,IAAWH,KAAKG,SAC/BH,KAAKsG,OAAOhI,EAAMU,GAGlBoD,MAAM+G,SAAS1I,EAAON,EAAQ7B,EAAMU,GAG5C,UACI,OAAOgB,KAAKqG,QAAQsG,QAAQ3M,KAAKwD,QAASxD,KAAK8C,UCfvD,MAAMsK,EAAkB,CACpB9K,YAAY,EACZ+K,eAAe,EACfC,uBAAuB,EACvBC,WAAW,EACXC,SAAS,GAGb,MAAM,UAAmB,EACrB,YAAYC,EAAU5M,GAElBuB,MAAM,KAAMvB,GACZb,KAAKyN,SAAWA,EAChBzN,KAAK8C,OAAS9C,KACdA,KAAK2H,QACL3H,KAAK0N,SAAW,IAAIC,iBAAkBrD,IAClCtK,KAAKiN,OAAO3C,KAEhBtK,KAAK0N,SAASE,QAAQ5N,KAAKwD,QAAS4J,GACpCpN,KAAKyH,SAET,OAAO1E,EAAO/D,GACV,OAAOgB,KAAKyN,SAASpO,OAAOW,KAAM+C,EAAO/D,GAE7C,KAAK6B,EAAM6B,GAAS,GAChB,OAAO1C,KAAKyN,SAAShM,KAAKZ,EAAM6B,GAEpC,MAAMO,EAAOQ,EAAQ,EAAMC,KACvB,OAAO1D,KAAKyN,SAASxK,MAAMA,EAAOQ,GAEtC,YAAYe,GACR,OAAOxE,KAAKyN,SAAS/I,YAAYF,GAErC,QACuB,MAAfxE,KAAK8C,QAGTV,MAAMuF,QAEV,SACIvF,MAAMyE,SACN7G,KAAK0N,SAASG,aAElB,SAASpN,EAAON,GACZH,KAAKiN,SACS,IAAVxM,GAAeN,IAAWH,KAAKG,SAC/BH,KAAK0G,SAASvB,QAASoC,IACnBA,EAAMxG,WAIVqB,MAAMiG,SAAS5H,EAAON,GAG9B,SAASM,EAAON,EAAQ7B,EAAMU,GAC1BgB,KAAKiN,SACL7K,MAAM+G,SAAS1I,EAAON,EAAQ7B,EAAMU,GAExC,SAASyB,EAAOzB,EAAOuH,GACnBvG,KAAKiN,SACL7K,MAAMgH,SAAS3I,EAAOzB,EAAOuH,GAEjC,SAAS+D,EAAY,GAAIZ,EAAU,IAC/BtH,MAAMuH,SAASD,GACf,MAAMoE,EAAepE,EAAQoE,cAAgB,IAAIzI,QAEjD,IAAI0I,EAAU/I,MAAMqC,KAAKrH,KAAK0N,SAASM,eAGvC,KAAOD,EAAQ5N,OAAS,GACpBmK,EAAUtI,KAAK+L,EAAQE,OAE3B,MAAMC,EAAO,CAAC5K,EAAM6K,GAAa,KACjB,MAAR7K,GAAgBA,IAAStD,MAGE,MAA3BsD,EAAKE,QAAQX,aAGZiL,EAAalL,IAAIU,EAAKE,UACvBsK,EAAavK,IAAID,EAAKE,QAAS,IAE/B2K,GACAD,EAAK5K,EAAKwC,UAGZ6D,EAAYrG,IAETwK,EAAalL,IAAIU,EAAKE,WAGvBF,aAAgB,GAChBA,EAAKoD,SAASvB,QAAQwE,GAE1BmE,EAAa9H,OAAO1C,EAAKE,SACzBF,EAAKqG,SAASD,KAElB,IAAI0E,EAAY9D,EAChB,IAAK,IAAIvM,EAAI,EAAGqQ,EAAUjO,OAAS,EAAGpC,GAAK,EAAG,CAC1C,GAAIA,GA5FgB,IA6FhB,MAAM,IAAImE,MAAM,mDA6BpB,IA3BAkM,EAAUjJ,QAASsF,IACf,MAAMnH,EAAOtD,KAAKyB,KAAKgJ,EAASxJ,QAAQ,GAC5B,MAARqC,IAGAA,EAAKE,UAAYiH,EAASxJ,SACJ,cAAlBwJ,EAASC,MACTwD,EAAKlO,KAAKyB,KAAKgJ,EAAS4D,iBAAiB,IACzCrJ,MAAMqC,KAAKoD,EAASF,YAAYpF,QAAStE,IACrC,MAAM0G,EAAQvH,KAAKyB,KAAKZ,GAAM,GAC9BqN,EAAK3G,GAAO,GACRA,aAAiB,GACjBA,EAAMb,SAASvB,QAASmJ,IACpBJ,EAAKI,GAAY,QAKN,eAAlB7D,EAASC,MACdwD,EAAK5K,EAAKtC,OAGlBkN,EAAK5K,MAETtD,KAAK0G,SAASvB,QAAQwE,GACtByE,EAAYpJ,MAAMqC,KAAKrH,KAAK0N,SAASM,eACrCD,EAAUK,EAAU7N,QACbwN,EAAQ5N,OAAS,GACpBmK,EAAUtI,KAAK+L,EAAQE,QAInC,OAAO3D,EAAWZ,EAAU,IACxBY,EAAYA,GAAatK,KAAK0N,SAASM,cACvC,MAAMF,EAAe,IAAIzI,QACzBiF,EACK7F,IAAKgG,IACN,MAAMnH,EAAO,EAAS7B,KAAKgJ,EAASxJ,QAAQ,GAC5C,OAAY,MAARqC,EACO,KAEPwK,EAAalL,IAAIU,EAAKE,UACtBsK,EAAalP,IAAI0E,EAAKE,SAASxB,KAAKyI,GAC7B,OAGPqD,EAAavK,IAAID,EAAKE,QAAS,CAACiH,IACzBnH,KAGV6B,QAAS7B,IACE,MAARA,GAAgBA,IAAStD,MAAQ8N,EAAalL,IAAIU,EAAKE,UACvDF,EAAK2J,OAAOa,EAAalP,IAAI0E,EAAKE,UAAY,GAAIkG,KAG1DA,EAAQoE,aAAeA,EACnBA,EAAalL,IAAI5C,KAAKwD,UACtBpB,MAAM6K,OAAOa,EAAalP,IAAIoB,KAAKwD,SAAUkG,GAEjD1J,KAAK2J,SAASW,EAAWZ,IAGjC,EAAW9E,SAAW,SACtB,EAAWiF,aAAe,EAC1B,EAAWd,gBAAkB,CAAC,EAAW,GACzC,EAAWtF,MAAQ,EAAMuF,WACzB,EAAW1E,QAAU,MACN,QC5Kf,MAAM,UAAiB,EACnB,YAAYxB,EAAQjC,GAChBuB,MAAMU,EAAQjC,GACdb,KAAK4D,KAAO5D,KAAKqG,QAAQrH,MAAMgB,KAAKwD,SAExC,cAAcxE,GACV,OAAOwG,SAAS+I,eAAevP,GAEnC,aAAawE,GACT,OAAOA,EAAQgL,KAEnB,SAAS/N,EAAON,GACZH,KAAKwD,QAAQgL,KAAOxO,KAAK4D,KACrB5D,KAAK4D,KAAKrD,MAAM,EAAGE,GAAST,KAAK4D,KAAKrD,MAAME,EAAQN,GAE5D,MAAMU,EAAMW,GACR,OAAIxB,KAAKwD,UAAY3C,EACVW,GAEH,EAEZ,SAASf,EAAOzB,EAAOuH,GACR,MAAPA,GACAvG,KAAK4D,KAAO5D,KAAK4D,KAAKrD,MAAM,EAAGE,GAASzB,EAAQgB,KAAK4D,KAAKrD,MAAME,GAChET,KAAKwD,QAAQgL,KAAOxO,KAAK4D,MAGzBxB,MAAMgH,SAAS3I,EAAOzB,EAAOuH,GAGrC,SACI,OAAOvG,KAAK4D,KAAKzD,OAErB,SAASuJ,GACLtH,MAAMuH,SAASD,GACf1J,KAAK4D,KAAO5D,KAAKqG,QAAQrH,MAAMgB,KAAKwD,SACX,IAArBxD,KAAK4D,KAAKzD,OACVH,KAAKe,SAEAf,KAAKU,gBAAgB,GAAYV,KAAKU,KAAKM,OAAShB,OACzDA,KAAKoJ,SAASpJ,KAAKG,SAAUH,KAAKU,KAAK1B,SACvCgB,KAAKU,KAAKK,UAGlB,SAASN,EAAO2K,GAAa,GACzB,MAAO,CAACpL,KAAKwD,QAAS/C,GAE1B,MAAMA,EAAOyJ,GAAQ,GACjB,IAAKA,EAAO,CACR,GAAc,IAAVzJ,EACA,OAAOT,KAEX,GAAIS,IAAUT,KAAKG,SACf,OAAOH,KAAKU,KAGpB,MAAMyJ,EAAQnK,KAAK8C,OAAOzD,OAAOW,KAAKwD,QAAQiL,UAAUhO,IAGxD,OAFAT,KAAK8F,OAAOzF,aAAa8J,EAAOnK,KAAKU,WAAQ+F,GAC7CzG,KAAK4D,KAAO5D,KAAKqG,QAAQrH,MAAMgB,KAAKwD,SAC7B2G,EAEX,OAAOG,EAAW3D,GACV2D,EAAUjG,KAAMoG,GACU,kBAAlBA,EAASC,MAA4BD,EAASxJ,SAAWjB,KAAKwD,WAEtExD,KAAK4D,KAAO5D,KAAKqG,QAAQrH,MAAMgB,KAAKwD,UAG5C,QACI,OAAOxD,KAAK4D,MAGpB,EAASgB,SAAW,OACpB,EAASnB,MAAQ,EAAM4H,YACR","file":"parchment.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Parchment\"] = factory();\n\telse\n\t\troot[\"Parchment\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","var Scope;\n(function (Scope) {\n    Scope[Scope[\"TYPE\"] = 3] = \"TYPE\";\n    Scope[Scope[\"LEVEL\"] = 12] = \"LEVEL\";\n    Scope[Scope[\"ATTRIBUTE\"] = 13] = \"ATTRIBUTE\";\n    Scope[Scope[\"BLOT\"] = 14] = \"BLOT\";\n    Scope[Scope[\"INLINE\"] = 7] = \"INLINE\";\n    Scope[Scope[\"BLOCK\"] = 11] = \"BLOCK\";\n    Scope[Scope[\"BLOCK_BLOT\"] = 10] = \"BLOCK_BLOT\";\n    Scope[Scope[\"INLINE_BLOT\"] = 6] = \"INLINE_BLOT\";\n    Scope[Scope[\"BLOCK_ATTRIBUTE\"] = 9] = \"BLOCK_ATTRIBUTE\";\n    Scope[Scope[\"INLINE_ATTRIBUTE\"] = 5] = \"INLINE_ATTRIBUTE\";\n    Scope[Scope[\"ANY\"] = 15] = \"ANY\";\n})(Scope || (Scope = {}));\nexport default Scope;\n","class LinkedList {\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.length = 0;\n    }\n    append(...nodes) {\n        this.insertBefore(nodes[0], null);\n        if (nodes.length > 1) {\n            const rest = nodes.slice(1);\n            this.append(...rest);\n        }\n    }\n    at(index) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur && index > 0) {\n            index -= 1;\n            cur = next();\n        }\n        return cur;\n    }\n    contains(node) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            if (cur === node) {\n                return true;\n            }\n            cur = next();\n        }\n        return false;\n    }\n    indexOf(node) {\n        const next = this.iterator();\n        let cur = next();\n        let index = 0;\n        while (cur) {\n            if (cur === node) {\n                return index;\n            }\n            index += 1;\n            cur = next();\n        }\n        return -1;\n    }\n    insertBefore(node, refNode) {\n        if (node == null) {\n            return;\n        }\n        this.remove(node);\n        node.next = refNode;\n        if (refNode != null) {\n            node.prev = refNode.prev;\n            if (refNode.prev != null) {\n                refNode.prev.next = node;\n            }\n            refNode.prev = node;\n            if (refNode === this.head) {\n                this.head = node;\n            }\n        }\n        else if (this.tail != null) {\n            this.tail.next = node;\n            node.prev = this.tail;\n            this.tail = node;\n        }\n        else {\n            node.prev = null;\n            this.head = this.tail = node;\n        }\n        this.length += 1;\n    }\n    offset(target) {\n        let index = 0;\n        let cur = this.head;\n        while (cur != null) {\n            if (cur === target) {\n                return index;\n            }\n            index += cur.length();\n            cur = cur.next;\n        }\n        return -1;\n    }\n    remove(node) {\n        if (!this.contains(node)) {\n            return;\n        }\n        if (node.prev != null) {\n            node.prev.next = node.next;\n        }\n        if (node.next != null) {\n            node.next.prev = node.prev;\n        }\n        if (node === this.head) {\n            this.head = node.next;\n        }\n        if (node === this.tail) {\n            this.tail = node.prev;\n        }\n        this.length -= 1;\n    }\n    iterator(curNode = this.head) {\n        // TODO use yield when we can\n        return () => {\n            const ret = curNode;\n            if (curNode != null) {\n                curNode = curNode.next;\n            }\n            return ret;\n        };\n    }\n    find(index, inclusive = false) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            const length = cur.length();\n            if (index < length ||\n                (inclusive &&\n                    index === length &&\n                    (cur.next == null || cur.next.length() !== 0))) {\n                return [cur, index];\n            }\n            index -= length;\n            cur = next();\n        }\n        return [null, 0];\n    }\n    forEach(callback) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            callback(cur);\n            cur = next();\n        }\n    }\n    forEachAt(index, length, callback) {\n        if (length <= 0) {\n            return;\n        }\n        const [startNode, offset] = this.find(index);\n        let curIndex = index - offset;\n        const next = this.iterator(startNode);\n        let cur = next();\n        while (cur && curIndex < index + length) {\n            const curLength = cur.length();\n            if (index > curIndex) {\n                callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));\n            }\n            else {\n                callback(cur, 0, Math.min(curLength, index + length - curIndex));\n            }\n            curIndex += curLength;\n            cur = next();\n        }\n    }\n    map(callback) {\n        return this.reduce((memo, cur) => {\n            memo.push(callback(cur));\n            return memo;\n        }, []);\n    }\n    reduce(callback, memo) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            memo = callback(memo, cur);\n            cur = next();\n        }\n        return memo;\n    }\n}\nexport default LinkedList;\n","export default class ParchmentError extends Error {\n    constructor(message) {\n        message = '[Parchment] ' + message;\n        super(message);\n        this.message = message;\n        this.name = this.constructor.name;\n    }\n}\n","import ParchmentError from './error';\nimport Scope from './scope';\nexport default class Registry {\n    constructor() {\n        this.attributes = {};\n        this.classes = {};\n        this.tags = {};\n        this.types = {};\n    }\n    static find(node, bubble = false) {\n        if (node == null) {\n            return null;\n        }\n        if (this.blots.has(node)) {\n            return this.blots.get(node) || null;\n        }\n        if (bubble) {\n            return this.find(node.parentNode, bubble);\n        }\n        return null;\n    }\n    create(scroll, input, value) {\n        const match = this.query(input);\n        if (match == null) {\n            throw new ParchmentError(`Unable to create ${input} blot`);\n        }\n        const blotClass = match;\n        const node = \n        // @ts-ignore\n        input instanceof Node || input.nodeType === Node.TEXT_NODE\n            ? input\n            : blotClass.create(value);\n        const blot = new blotClass(scroll, node, value);\n        Registry.blots.set(blot.domNode, blot);\n        return blot;\n    }\n    find(node, bubble = false) {\n        return Registry.find(node, bubble);\n    }\n    query(query, scope = Scope.ANY) {\n        let match;\n        if (typeof query === 'string') {\n            match = this.types[query] || this.attributes[query];\n            // @ts-ignore\n        }\n        else if (query instanceof Text || query.nodeType === Node.TEXT_NODE) {\n            match = this.types.text;\n        }\n        else if (typeof query === 'number') {\n            if (query & Scope.LEVEL & Scope.BLOCK) {\n                match = this.types.block;\n            }\n            else if (query & Scope.LEVEL & Scope.INLINE) {\n                match = this.types.inline;\n            }\n        }\n        else if (query instanceof HTMLElement) {\n            const names = (query.getAttribute('class') || '').split(/\\s+/);\n            names.some((name) => {\n                match = this.classes[name];\n                if (match) {\n                    return true;\n                }\n                return false;\n            });\n            match = match || this.tags[query.tagName];\n        }\n        if (match == null) {\n            return null;\n        }\n        // @ts-ignore\n        if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope) {\n            return match;\n        }\n        return null;\n    }\n    register(...definitions) {\n        if (definitions.length > 1) {\n            return definitions.map((d) => {\n                return this.register(d);\n            });\n        }\n        const definition = definitions[0];\n        if (typeof definition.blotName !== 'string' &&\n            typeof definition.attrName !== 'string') {\n            throw new ParchmentError('Invalid definition');\n        }\n        else if (definition.blotName === 'abstract') {\n            throw new ParchmentError('Cannot register abstract class');\n        }\n        this.types[definition.blotName || definition.attrName] = definition;\n        if (typeof definition.keyName === 'string') {\n            this.attributes[definition.keyName] = definition;\n        }\n        else {\n            if (definition.className != null) {\n                this.classes[definition.className] = definition;\n            }\n            if (definition.tagName != null) {\n                if (Array.isArray(definition.tagName)) {\n                    definition.tagName = definition.tagName.map((tagName) => {\n                        return tagName.toUpperCase();\n                    });\n                }\n                else {\n                    definition.tagName = definition.tagName.toUpperCase();\n                }\n                const tagNames = Array.isArray(definition.tagName)\n                    ? definition.tagName\n                    : [definition.tagName];\n                tagNames.forEach((tag) => {\n                    if (this.tags[tag] == null || definition.className == null) {\n                        this.tags[tag] = definition;\n                    }\n                });\n            }\n        }\n        return definition;\n    }\n}\nRegistry.blots = new WeakMap();\n","import ParchmentError from '../../error';\nimport Registry from '../../registry';\nimport Scope from '../../scope';\nclass ShadowBlot {\n    constructor(scroll, domNode) {\n        this.scroll = scroll;\n        this.domNode = domNode;\n        Registry.blots.set(domNode, this);\n        this.prev = null;\n        this.next = null;\n    }\n    static create(value) {\n        if (this.tagName == null) {\n            throw new ParchmentError('Blot definition missing tagName');\n        }\n        let node;\n        if (Array.isArray(this.tagName)) {\n            if (typeof value === 'string') {\n                value = value.toUpperCase();\n                if (parseInt(value, 10).toString() === value) {\n                    value = parseInt(value, 10);\n                }\n            }\n            if (typeof value === 'number') {\n                node = document.createElement(this.tagName[value - 1]);\n            }\n            else if (this.tagName.indexOf(value) > -1) {\n                node = document.createElement(value);\n            }\n            else {\n                node = document.createElement(this.tagName[0]);\n            }\n        }\n        else {\n            node = document.createElement(this.tagName);\n        }\n        if (this.className) {\n            node.classList.add(this.className);\n        }\n        return node;\n    }\n    // Hack for accessing inherited static methods\n    get statics() {\n        return this.constructor;\n    }\n    attach() {\n        // Nothing to do\n    }\n    clone() {\n        const domNode = this.domNode.cloneNode(false);\n        return this.scroll.create(domNode);\n    }\n    detach() {\n        if (this.parent != null) {\n            this.parent.removeChild(this);\n        }\n        Registry.blots.delete(this.domNode);\n    }\n    deleteAt(index, length) {\n        const blot = this.isolate(index, length);\n        blot.remove();\n    }\n    formatAt(index, length, name, value) {\n        const blot = this.isolate(index, length);\n        if (this.scroll.query(name, Scope.BLOT) != null && value) {\n            blot.wrap(name, value);\n        }\n        else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n            const parent = this.scroll.create(this.statics.scope);\n            blot.wrap(parent);\n            parent.format(name, value);\n        }\n    }\n    insertAt(index, value, def) {\n        const blot = def == null\n            ? this.scroll.create('text', value)\n            : this.scroll.create(value, def);\n        const ref = this.split(index);\n        this.parent.insertBefore(blot, ref || undefined);\n    }\n    isolate(index, length) {\n        const target = this.split(index);\n        if (target == null) {\n            throw new Error('Attempt to isolate at end');\n        }\n        target.split(length);\n        return target;\n    }\n    length() {\n        return 1;\n    }\n    offset(root = this.parent) {\n        if (this.parent == null || this === root) {\n            return 0;\n        }\n        return this.parent.children.offset(this) + this.parent.offset(root);\n    }\n    optimize(_context) {\n        if (this.statics.requiredContainer &&\n            !(this.parent instanceof this.statics.requiredContainer)) {\n            this.wrap(this.statics.requiredContainer.blotName);\n        }\n    }\n    remove() {\n        if (this.domNode.parentNode != null) {\n            this.domNode.parentNode.removeChild(this.domNode);\n        }\n        this.detach();\n    }\n    replaceWith(name, value) {\n        const replacement = typeof name === 'string' ? this.scroll.create(name, value) : name;\n        if (this.parent != null) {\n            this.parent.insertBefore(replacement, this.next || undefined);\n            this.remove();\n        }\n        return replacement;\n    }\n    split(index, _force) {\n        return index === 0 ? this : this.next;\n    }\n    update(_mutations, _context) {\n        // Nothing to do by default\n    }\n    wrap(name, value) {\n        const wrapper = typeof name === 'string'\n            ? this.scroll.create(name, value)\n            : name;\n        if (this.parent != null) {\n            this.parent.insertBefore(wrapper, this.next || undefined);\n        }\n        if (typeof wrapper.appendChild !== 'function') {\n            throw new ParchmentError(`Cannot wrap ${name}`);\n        }\n        wrapper.appendChild(this);\n        return wrapper;\n    }\n}\nShadowBlot.blotName = 'abstract';\nexport default ShadowBlot;\n","import LinkedList from '../../collection/linked-list';\nimport ParchmentError from '../../error';\nimport Scope from '../../scope';\nimport ShadowBlot from './shadow';\nfunction makeAttachedBlot(node, scroll) {\n    let blot = scroll.find(node);\n    if (blot == null) {\n        try {\n            blot = scroll.create(node);\n        }\n        catch (e) {\n            blot = scroll.create(Scope.INLINE);\n            Array.from(node.childNodes).forEach((child) => {\n                // @ts-ignore\n                blot.domNode.appendChild(child);\n            });\n            if (node.parentNode) {\n                node.parentNode.replaceChild(blot.domNode, node);\n            }\n            blot.attach();\n        }\n    }\n    return blot;\n}\nclass ParentBlot extends ShadowBlot {\n    constructor(scroll, domNode) {\n        super(scroll, domNode);\n        this.uiNode = null;\n        this.build();\n    }\n    appendChild(other) {\n        this.insertBefore(other);\n    }\n    attach() {\n        super.attach();\n        this.children.forEach((child) => {\n            child.attach();\n        });\n    }\n    attachUI(node) {\n        if (this.uiNode != null) {\n            this.uiNode.remove();\n        }\n        this.uiNode = node;\n        if (ParentBlot.uiClass) {\n            this.uiNode.classList.add(ParentBlot.uiClass);\n        }\n        this.uiNode.setAttribute('contenteditable', 'false');\n        this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n    }\n    build() {\n        this.children = new LinkedList();\n        // Need to be reversed for if DOM nodes already in order\n        Array.from(this.domNode.childNodes)\n            .filter((node) => node !== this.uiNode)\n            .reverse()\n            .forEach((node) => {\n            try {\n                const child = makeAttachedBlot(node, this.scroll);\n                this.insertBefore(child, this.children.head || undefined);\n            }\n            catch (err) {\n                if (err instanceof ParchmentError) {\n                    return;\n                }\n                else {\n                    throw err;\n                }\n            }\n        });\n    }\n    deleteAt(index, length) {\n        if (index === 0 && length === this.length()) {\n            return this.remove();\n        }\n        this.children.forEachAt(index, length, (child, offset, childLength) => {\n            child.deleteAt(offset, childLength);\n        });\n    }\n    descendant(criteria, index = 0) {\n        const [child, offset] = this.children.find(index);\n        if ((criteria.blotName == null && criteria(child)) ||\n            (criteria.blotName != null && child instanceof criteria)) {\n            return [child, offset];\n        }\n        else if (child instanceof ParentBlot) {\n            return child.descendant(criteria, offset);\n        }\n        else {\n            return [null, -1];\n        }\n    }\n    descendants(criteria, index = 0, length = Number.MAX_VALUE) {\n        let descendants = [];\n        let lengthLeft = length;\n        this.children.forEachAt(index, length, (child, childIndex, childLength) => {\n            if ((criteria.blotName == null && criteria(child)) ||\n                (criteria.blotName != null && child instanceof criteria)) {\n                descendants.push(child);\n            }\n            if (child instanceof ParentBlot) {\n                descendants = descendants.concat(child.descendants(criteria, childIndex, lengthLeft));\n            }\n            lengthLeft -= childLength;\n        });\n        return descendants;\n    }\n    detach() {\n        this.children.forEach((child) => {\n            child.detach();\n        });\n        super.detach();\n    }\n    enforceAllowedChildren() {\n        let done = false;\n        this.children.forEach((child) => {\n            if (done) {\n                return;\n            }\n            const allowed = this.statics.allowedChildren.some((def) => child instanceof def);\n            if (allowed) {\n                return;\n            }\n            if (child.statics.scope === Scope.BLOCK_BLOT) {\n                if (child.next != null) {\n                    this.splitAfter(child);\n                }\n                if (child.prev != null) {\n                    this.splitAfter(child.prev);\n                }\n                child.parent.unwrap();\n                done = true;\n            }\n            else if (child instanceof ParentBlot) {\n                child.unwrap();\n            }\n            else {\n                child.remove();\n            }\n        });\n    }\n    formatAt(index, length, name, value) {\n        this.children.forEachAt(index, length, (child, offset, childLength) => {\n            child.formatAt(offset, childLength, name, value);\n        });\n    }\n    insertAt(index, value, def) {\n        const [child, offset] = this.children.find(index);\n        if (child) {\n            child.insertAt(offset, value, def);\n        }\n        else {\n            const blot = def == null\n                ? this.scroll.create('text', value)\n                : this.scroll.create(value, def);\n            this.appendChild(blot);\n        }\n    }\n    insertBefore(childBlot, refBlot) {\n        if (childBlot.parent != null) {\n            childBlot.parent.children.remove(childBlot);\n        }\n        let refDomNode = null;\n        this.children.insertBefore(childBlot, refBlot || null);\n        childBlot.parent = this;\n        if (refBlot != null) {\n            refDomNode = refBlot.domNode;\n        }\n        if (this.domNode.parentNode !== childBlot.domNode ||\n            this.domNode.nextSibling !== refDomNode) {\n            this.domNode.insertBefore(childBlot.domNode, refDomNode);\n        }\n        childBlot.attach();\n    }\n    length() {\n        return this.children.reduce((memo, child) => {\n            return memo + child.length();\n        }, 0);\n    }\n    moveChildren(targetParent, refNode) {\n        this.children.forEach((child) => {\n            targetParent.insertBefore(child, refNode);\n        });\n    }\n    optimize(context) {\n        super.optimize(context);\n        this.enforceAllowedChildren();\n        if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {\n            this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n        }\n        if (this.children.length === 0) {\n            if (this.statics.defaultChild != null) {\n                const child = this.scroll.create(this.statics.defaultChild.blotName);\n                this.appendChild(child);\n                // TODO double check if necessary\n                // child.optimize(context);\n            }\n            else {\n                this.remove();\n            }\n        }\n    }\n    path(index, inclusive = false) {\n        const [child, offset] = this.children.find(index, inclusive);\n        const position = [[this, index]];\n        if (child instanceof ParentBlot) {\n            return position.concat(child.path(offset, inclusive));\n        }\n        else if (child != null) {\n            position.push([child, offset]);\n        }\n        return position;\n    }\n    removeChild(child) {\n        this.children.remove(child);\n    }\n    replaceWith(name, value) {\n        const replacement = typeof name === 'string' ? this.scroll.create(name, value) : name;\n        if (replacement instanceof ParentBlot) {\n            this.moveChildren(replacement);\n        }\n        return super.replaceWith(replacement);\n    }\n    split(index, force = false) {\n        if (!force) {\n            if (index === 0) {\n                return this;\n            }\n            if (index === this.length()) {\n                return this.next;\n            }\n        }\n        const after = this.clone();\n        if (this.parent) {\n            this.parent.insertBefore(after, this.next || undefined);\n        }\n        this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n            const split = child.split(offset, force);\n            if (split != null) {\n                after.appendChild(split);\n            }\n        });\n        return after;\n    }\n    splitAfter(child) {\n        const after = this.clone();\n        while (child.next != null) {\n            after.appendChild(child.next);\n        }\n        if (this.parent) {\n            this.parent.insertBefore(after, this.next || undefined);\n        }\n        return after;\n    }\n    unwrap() {\n        if (this.parent) {\n            this.moveChildren(this.parent, this.next || undefined);\n        }\n        this.remove();\n    }\n    update(mutations, _context) {\n        const addedNodes = [];\n        const removedNodes = [];\n        mutations.forEach((mutation) => {\n            if (mutation.target === this.domNode && mutation.type === 'childList') {\n                addedNodes.push(...mutation.addedNodes);\n                removedNodes.push(...mutation.removedNodes);\n            }\n        });\n        removedNodes.forEach((node) => {\n            // Check node has actually been removed\n            // One exception is Chrome does not immediately remove IFRAMEs\n            // from DOM but MutationRecord is correct in its reported removal\n            if (node.parentNode != null &&\n                // @ts-ignore\n                node.tagName !== 'IFRAME' &&\n                document.body.compareDocumentPosition(node) &\n                    Node.DOCUMENT_POSITION_CONTAINED_BY) {\n                return;\n            }\n            const blot = this.scroll.find(node);\n            if (blot == null) {\n                return;\n            }\n            if (blot.domNode.parentNode == null ||\n                blot.domNode.parentNode === this.domNode) {\n                blot.detach();\n            }\n        });\n        addedNodes\n            .filter((node) => {\n            return node.parentNode === this.domNode || node === this.uiNode;\n        })\n            .sort((a, b) => {\n            if (a === b) {\n                return 0;\n            }\n            if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n                return 1;\n            }\n            return -1;\n        })\n            .forEach((node) => {\n            let refBlot = null;\n            if (node.nextSibling != null) {\n                refBlot = this.scroll.find(node.nextSibling);\n            }\n            const blot = makeAttachedBlot(node, this.scroll);\n            if (blot.next !== refBlot || blot.next == null) {\n                if (blot.parent != null) {\n                    blot.parent.removeChild(this);\n                }\n                this.insertBefore(blot, refBlot || undefined);\n            }\n        });\n        this.enforceAllowedChildren();\n    }\n}\nParentBlot.uiClass = '';\nexport default ParentBlot;\n","import Scope from '../../scope';\nimport ParentBlot from './parent';\nclass ContainerBlot extends ParentBlot {\n    checkMerge() {\n        return (this.next !== null && this.next.statics.blotName === this.statics.blotName);\n    }\n    deleteAt(index, length) {\n        super.deleteAt(index, length);\n        this.enforceAllowedChildren();\n    }\n    formatAt(index, length, name, value) {\n        super.formatAt(index, length, name, value);\n        this.enforceAllowedChildren();\n    }\n    insertAt(index, value, def) {\n        super.insertAt(index, value, def);\n        this.enforceAllowedChildren();\n    }\n    optimize(context) {\n        super.optimize(context);\n        if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n            this.next.moveChildren(this);\n            this.next.remove();\n        }\n    }\n}\nContainerBlot.blotName = 'container';\nContainerBlot.scope = Scope.BLOCK_BLOT;\nexport default ContainerBlot;\n","import Scope from '../../scope';\nimport ShadowBlot from './shadow';\nclass LeafBlot extends ShadowBlot {\n    static value(_domNode) {\n        return true;\n    }\n    index(node, offset) {\n        if (this.domNode === node ||\n            this.domNode.compareDocumentPosition(node) &\n                Node.DOCUMENT_POSITION_CONTAINED_BY) {\n            return Math.min(offset, 1);\n        }\n        return -1;\n    }\n    position(index, _inclusive) {\n        const childNodes = Array.from(this.parent.domNode.childNodes);\n        let offset = childNodes.indexOf(this.domNode);\n        if (index > 0) {\n            offset += 1;\n        }\n        return [this.parent.domNode, offset];\n    }\n    value() {\n        return {\n            [this.statics.blotName]: this.statics.value(this.domNode) || true,\n        };\n    }\n}\nLeafBlot.scope = Scope.INLINE_BLOT;\nexport default LeafBlot;\n","import Scope from '../scope';\nexport default class Attributor {\n    constructor(attrName, keyName, options = {}) {\n        this.attrName = attrName;\n        this.keyName = keyName;\n        const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n        this.scope =\n            options.scope != null\n                ? // Ignore type bits, force attribute bit\n                    (options.scope & Scope.LEVEL) | attributeBit\n                : Scope.ATTRIBUTE;\n        if (options.whitelist != null) {\n            this.whitelist = options.whitelist;\n        }\n    }\n    static keys(node) {\n        return Array.from(node.attributes).map((item) => item.name);\n    }\n    add(node, value) {\n        if (!this.canAdd(node, value)) {\n            return false;\n        }\n        node.setAttribute(this.keyName, value);\n        return true;\n    }\n    canAdd(_node, value) {\n        if (this.whitelist == null) {\n            return true;\n        }\n        if (typeof value === 'string') {\n            return this.whitelist.indexOf(value.replace(/[\"']/g, '')) > -1;\n        }\n        else {\n            return this.whitelist.indexOf(value) > -1;\n        }\n    }\n    remove(node) {\n        node.removeAttribute(this.keyName);\n    }\n    value(node) {\n        const value = node.getAttribute(this.keyName);\n        if (this.canAdd(node, value) && value) {\n            return value;\n        }\n        return '';\n    }\n}\n","import Attributor from './attributor';\nfunction match(node, prefix) {\n    const className = node.getAttribute('class') || '';\n    return className\n        .split(/\\s+/)\n        .filter((name) => name.indexOf(`${prefix}-`) === 0);\n}\nclass ClassAttributor extends Attributor {\n    static keys(node) {\n        return (node.getAttribute('class') || '')\n            .split(/\\s+/)\n            .map((name) => name.split('-').slice(0, -1).join('-'));\n    }\n    add(node, value) {\n        if (!this.canAdd(node, value)) {\n            return false;\n        }\n        this.remove(node);\n        node.classList.add(`${this.keyName}-${value}`);\n        return true;\n    }\n    remove(node) {\n        const matches = match(node, this.keyName);\n        matches.forEach((name) => {\n            node.classList.remove(name);\n        });\n        if (node.classList.length === 0) {\n            node.removeAttribute('class');\n        }\n    }\n    value(node) {\n        const result = match(node, this.keyName)[0] || '';\n        const value = result.slice(this.keyName.length + 1); // +1 for hyphen\n        return this.canAdd(node, value) ? value : '';\n    }\n}\nexport default ClassAttributor;\n","import Attributor from './attributor';\nfunction camelize(name) {\n    const parts = name.split('-');\n    const rest = parts\n        .slice(1)\n        .map((part) => part[0].toUpperCase() + part.slice(1))\n        .join('');\n    return parts[0] + rest;\n}\nclass StyleAttributor extends Attributor {\n    static keys(node) {\n        return (node.getAttribute('style') || '').split(';').map((value) => {\n            const arr = value.split(':');\n            return arr[0].trim();\n        });\n    }\n    add(node, value) {\n        if (!this.canAdd(node, value)) {\n            return false;\n        }\n        // @ts-ignore\n        node.style[camelize(this.keyName)] = value;\n        return true;\n    }\n    remove(node) {\n        // @ts-ignore\n        node.style[camelize(this.keyName)] = '';\n        if (!node.getAttribute('style')) {\n            node.removeAttribute('style');\n        }\n    }\n    value(node) {\n        // @ts-ignore\n        const value = node.style[camelize(this.keyName)];\n        return this.canAdd(node, value) ? value : '';\n    }\n}\nexport default StyleAttributor;\n","import Registry from '../registry';\nimport Scope from '../scope';\nimport Attributor from './attributor';\nimport ClassAttributor from './class';\nimport StyleAttributor from './style';\nclass AttributorStore {\n    constructor(domNode) {\n        this.attributes = {};\n        this.domNode = domNode;\n        this.build();\n    }\n    attribute(attribute, value) {\n        // verb\n        if (value) {\n            if (attribute.add(this.domNode, value)) {\n                if (attribute.value(this.domNode) != null) {\n                    this.attributes[attribute.attrName] = attribute;\n                }\n                else {\n                    delete this.attributes[attribute.attrName];\n                }\n            }\n        }\n        else {\n            attribute.remove(this.domNode);\n            delete this.attributes[attribute.attrName];\n        }\n    }\n    build() {\n        this.attributes = {};\n        const blot = Registry.find(this.domNode);\n        if (blot == null) {\n            return;\n        }\n        const attributes = Attributor.keys(this.domNode);\n        const classes = ClassAttributor.keys(this.domNode);\n        const styles = StyleAttributor.keys(this.domNode);\n        attributes\n            .concat(classes)\n            .concat(styles)\n            .forEach((name) => {\n            const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n            if (attr instanceof Attributor) {\n                this.attributes[attr.attrName] = attr;\n            }\n        });\n    }\n    copy(target) {\n        Object.keys(this.attributes).forEach((key) => {\n            const value = this.attributes[key].value(this.domNode);\n            target.format(key, value);\n        });\n    }\n    move(target) {\n        this.copy(target);\n        Object.keys(this.attributes).forEach((key) => {\n            this.attributes[key].remove(this.domNode);\n        });\n        this.attributes = {};\n    }\n    values() {\n        return Object.keys(this.attributes).reduce((attributes, name) => {\n            attributes[name] = this.attributes[name].value(this.domNode);\n            return attributes;\n        }, {});\n    }\n}\nexport default AttributorStore;\n","import Attributor from '../attributor/attributor';\nimport AttributorStore from '../attributor/store';\nimport Scope from '../scope';\nimport LeafBlot from './abstract/leaf';\nimport ParentBlot from './abstract/parent';\n// Shallow object comparison\nfunction isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n        return false;\n    }\n    // @ts-ignore\n    for (const prop in obj1) {\n        // @ts-ignore\n        if (obj1[prop] !== obj2[prop]) {\n            return false;\n        }\n    }\n    return true;\n}\nclass InlineBlot extends ParentBlot {\n    constructor(scroll, domNode) {\n        super(scroll, domNode);\n        this.attributes = new AttributorStore(this.domNode);\n    }\n    static formats(domNode, scroll) {\n        const match = scroll.query(InlineBlot.blotName);\n        if (match != null &&\n            domNode.tagName === match.tagName) {\n            return undefined;\n        }\n        else if (typeof this.tagName === 'string') {\n            return true;\n        }\n        else if (Array.isArray(this.tagName)) {\n            return domNode.tagName.toLowerCase();\n        }\n        return undefined;\n    }\n    format(name, value) {\n        if (name === this.statics.blotName && !value) {\n            this.children.forEach((child) => {\n                if (!(child instanceof InlineBlot)) {\n                    child = child.wrap(InlineBlot.blotName, true);\n                }\n                this.attributes.copy(child);\n            });\n            this.unwrap();\n        }\n        else {\n            const format = this.scroll.query(name, Scope.INLINE);\n            if (format == null) {\n                return;\n            }\n            if (format instanceof Attributor) {\n                this.attributes.attribute(format, value);\n            }\n            else if (value &&\n                (name !== this.statics.blotName || this.formats()[name] !== value)) {\n                this.replaceWith(name, value);\n            }\n        }\n    }\n    formats() {\n        const formats = this.attributes.values();\n        const format = this.statics.formats(this.domNode, this.scroll);\n        if (format != null) {\n            formats[this.statics.blotName] = format;\n        }\n        return formats;\n    }\n    formatAt(index, length, name, value) {\n        if (this.formats()[name] != null ||\n            this.scroll.query(name, Scope.ATTRIBUTE)) {\n            const blot = this.isolate(index, length);\n            blot.format(name, value);\n        }\n        else {\n            super.formatAt(index, length, name, value);\n        }\n    }\n    optimize(context) {\n        super.optimize(context);\n        const formats = this.formats();\n        if (Object.keys(formats).length === 0) {\n            return this.unwrap(); // unformatted span\n        }\n        const next = this.next;\n        if (next instanceof InlineBlot &&\n            next.prev === this &&\n            isEqual(formats, next.formats())) {\n            next.moveChildren(this);\n            next.remove();\n        }\n    }\n    replaceWith(name, value) {\n        const replacement = super.replaceWith(name, value);\n        this.attributes.copy(replacement);\n        return replacement;\n    }\n    update(mutations, context) {\n        super.update(mutations, context);\n        const attributeChanged = mutations.some((mutation) => mutation.target === this.domNode && mutation.type === 'attributes');\n        if (attributeChanged) {\n            this.attributes.build();\n        }\n    }\n    wrap(name, value) {\n        const wrapper = super.wrap(name, value);\n        if (wrapper instanceof InlineBlot) {\n            this.attributes.move(wrapper);\n        }\n        return wrapper;\n    }\n}\nInlineBlot.allowedChildren = [InlineBlot, LeafBlot];\nInlineBlot.blotName = 'inline';\nInlineBlot.scope = Scope.INLINE_BLOT;\nInlineBlot.tagName = 'SPAN';\nexport default InlineBlot;\n","import Attributor from '../attributor/attributor';\nimport AttributorStore from '../attributor/store';\nimport Scope from '../scope';\nimport LeafBlot from './abstract/leaf';\nimport ParentBlot from './abstract/parent';\nimport InlineBlot from './inline';\nclass BlockBlot extends ParentBlot {\n    constructor(scroll, domNode) {\n        super(scroll, domNode);\n        this.attributes = new AttributorStore(this.domNode);\n    }\n    static formats(domNode, scroll) {\n        const match = scroll.query(BlockBlot.blotName);\n        if (match != null &&\n            domNode.tagName === match.tagName) {\n            return undefined;\n        }\n        else if (typeof this.tagName === 'string') {\n            return true;\n        }\n        else if (Array.isArray(this.tagName)) {\n            return domNode.tagName.toLowerCase();\n        }\n    }\n    format(name, value) {\n        const format = this.scroll.query(name, Scope.BLOCK);\n        if (format == null) {\n            return;\n        }\n        else if (format instanceof Attributor) {\n            this.attributes.attribute(format, value);\n        }\n        else if (name === this.statics.blotName && !value) {\n            this.replaceWith(BlockBlot.blotName);\n        }\n        else if (value &&\n            (name !== this.statics.blotName || this.formats()[name] !== value)) {\n            this.replaceWith(name, value);\n        }\n    }\n    formats() {\n        const formats = this.attributes.values();\n        const format = this.statics.formats(this.domNode, this.scroll);\n        if (format != null) {\n            formats[this.statics.blotName] = format;\n        }\n        return formats;\n    }\n    formatAt(index, length, name, value) {\n        if (this.scroll.query(name, Scope.BLOCK) != null) {\n            this.format(name, value);\n        }\n        else {\n            super.formatAt(index, length, name, value);\n        }\n    }\n    insertAt(index, value, def) {\n        if (def == null || this.scroll.query(value, Scope.INLINE) != null) {\n            // Insert text or inline\n            super.insertAt(index, value, def);\n        }\n        else {\n            const after = this.split(index);\n            if (after != null) {\n                const blot = this.scroll.create(value, def);\n                after.parent.insertBefore(blot, after);\n            }\n            else {\n                throw new Error('Attempt to insertAt after block boundaries');\n            }\n        }\n    }\n    replaceWith(name, value) {\n        const replacement = super.replaceWith(name, value);\n        this.attributes.copy(replacement);\n        return replacement;\n    }\n    update(mutations, context) {\n        super.update(mutations, context);\n        const attributeChanged = mutations.some((mutation) => mutation.target === this.domNode && mutation.type === 'attributes');\n        if (attributeChanged) {\n            this.attributes.build();\n        }\n    }\n}\nBlockBlot.blotName = 'block';\nBlockBlot.scope = Scope.BLOCK_BLOT;\nBlockBlot.tagName = 'P';\nBlockBlot.allowedChildren = [\n    InlineBlot,\n    BlockBlot,\n    LeafBlot,\n];\nexport default BlockBlot;\n","import LeafBlot from './abstract/leaf';\nclass EmbedBlot extends LeafBlot {\n    static formats(_domNode, _scroll) {\n        return undefined;\n    }\n    format(name, value) {\n        // super.formatAt wraps, which is what we want in general,\n        // but this allows subclasses to overwrite for formats\n        // that just apply to particular embeds\n        super.formatAt(0, this.length(), name, value);\n    }\n    formatAt(index, length, name, value) {\n        if (index === 0 && length === this.length()) {\n            this.format(name, value);\n        }\n        else {\n            super.formatAt(index, length, name, value);\n        }\n    }\n    formats() {\n        return this.statics.formats(this.domNode, this.scroll);\n    }\n}\nexport default EmbedBlot;\n","import Registry from '../registry';\nimport Scope from '../scope';\nimport ContainerBlot from './abstract/container';\nimport ParentBlot from './abstract/parent';\nimport BlockBlot from './block';\nconst OBSERVER_CONFIG = {\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n};\nconst MAX_OPTIMIZE_ITERATIONS = 100;\nclass ScrollBlot extends ParentBlot {\n    constructor(registry, node) {\n        // @ts-ignore\n        super(null, node);\n        this.registry = registry;\n        this.scroll = this;\n        this.build();\n        this.observer = new MutationObserver((mutations) => {\n            this.update(mutations);\n        });\n        this.observer.observe(this.domNode, OBSERVER_CONFIG);\n        this.attach();\n    }\n    create(input, value) {\n        return this.registry.create(this, input, value);\n    }\n    find(node, bubble = false) {\n        return this.registry.find(node, bubble);\n    }\n    query(query, scope = Scope.ANY) {\n        return this.registry.query(query, scope);\n    }\n    register(...definitions) {\n        return this.registry.register(...definitions);\n    }\n    build() {\n        if (this.scroll == null) {\n            return;\n        }\n        super.build();\n    }\n    detach() {\n        super.detach();\n        this.observer.disconnect();\n    }\n    deleteAt(index, length) {\n        this.update();\n        if (index === 0 && length === this.length()) {\n            this.children.forEach((child) => {\n                child.remove();\n            });\n        }\n        else {\n            super.deleteAt(index, length);\n        }\n    }\n    formatAt(index, length, name, value) {\n        this.update();\n        super.formatAt(index, length, name, value);\n    }\n    insertAt(index, value, def) {\n        this.update();\n        super.insertAt(index, value, def);\n    }\n    optimize(mutations = [], context = {}) {\n        super.optimize(context);\n        const mutationsMap = context.mutationsMap || new WeakMap();\n        // We must modify mutations directly, cannot make copy and then modify\n        let records = Array.from(this.observer.takeRecords());\n        // Array.push currently seems to be implemented by a non-tail recursive function\n        // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n        while (records.length > 0) {\n            mutations.push(records.pop());\n        }\n        const mark = (blot, markParent = true) => {\n            if (blot == null || blot === this) {\n                return;\n            }\n            if (blot.domNode.parentNode == null) {\n                return;\n            }\n            if (!mutationsMap.has(blot.domNode)) {\n                mutationsMap.set(blot.domNode, []);\n            }\n            if (markParent) {\n                mark(blot.parent);\n            }\n        };\n        const optimize = (blot) => {\n            // Post-order traversal\n            if (!mutationsMap.has(blot.domNode)) {\n                return;\n            }\n            if (blot instanceof ParentBlot) {\n                blot.children.forEach(optimize);\n            }\n            mutationsMap.delete(blot.domNode);\n            blot.optimize(context);\n        };\n        let remaining = mutations;\n        for (let i = 0; remaining.length > 0; i += 1) {\n            if (i >= MAX_OPTIMIZE_ITERATIONS) {\n                throw new Error('[Parchment] Maximum optimize iterations reached');\n            }\n            remaining.forEach((mutation) => {\n                const blot = this.find(mutation.target, true);\n                if (blot == null) {\n                    return;\n                }\n                if (blot.domNode === mutation.target) {\n                    if (mutation.type === 'childList') {\n                        mark(this.find(mutation.previousSibling, false));\n                        Array.from(mutation.addedNodes).forEach((node) => {\n                            const child = this.find(node, false);\n                            mark(child, false);\n                            if (child instanceof ParentBlot) {\n                                child.children.forEach((grandChild) => {\n                                    mark(grandChild, false);\n                                });\n                            }\n                        });\n                    }\n                    else if (mutation.type === 'attributes') {\n                        mark(blot.prev);\n                    }\n                }\n                mark(blot);\n            });\n            this.children.forEach(optimize);\n            remaining = Array.from(this.observer.takeRecords());\n            records = remaining.slice();\n            while (records.length > 0) {\n                mutations.push(records.pop());\n            }\n        }\n    }\n    update(mutations, context = {}) {\n        mutations = mutations || this.observer.takeRecords();\n        const mutationsMap = new WeakMap();\n        mutations\n            .map((mutation) => {\n            const blot = Registry.find(mutation.target, true);\n            if (blot == null) {\n                return null;\n            }\n            if (mutationsMap.has(blot.domNode)) {\n                mutationsMap.get(blot.domNode).push(mutation);\n                return null;\n            }\n            else {\n                mutationsMap.set(blot.domNode, [mutation]);\n                return blot;\n            }\n        })\n            .forEach((blot) => {\n            if (blot != null && blot !== this && mutationsMap.has(blot.domNode)) {\n                blot.update(mutationsMap.get(blot.domNode) || [], context);\n            }\n        });\n        context.mutationsMap = mutationsMap;\n        if (mutationsMap.has(this.domNode)) {\n            super.update(mutationsMap.get(this.domNode), context);\n        }\n        this.optimize(mutations, context);\n    }\n}\nScrollBlot.blotName = 'scroll';\nScrollBlot.defaultChild = BlockBlot;\nScrollBlot.allowedChildren = [BlockBlot, ContainerBlot];\nScrollBlot.scope = Scope.BLOCK_BLOT;\nScrollBlot.tagName = 'DIV';\nexport default ScrollBlot;\n","import Scope from '../scope';\nimport LeafBlot from './abstract/leaf';\nclass TextBlot extends LeafBlot {\n    constructor(scroll, node) {\n        super(scroll, node);\n        this.text = this.statics.value(this.domNode);\n    }\n    static create(value) {\n        return document.createTextNode(value);\n    }\n    static value(domNode) {\n        return domNode.data;\n    }\n    deleteAt(index, length) {\n        this.domNode.data = this.text =\n            this.text.slice(0, index) + this.text.slice(index + length);\n    }\n    index(node, offset) {\n        if (this.domNode === node) {\n            return offset;\n        }\n        return -1;\n    }\n    insertAt(index, value, def) {\n        if (def == null) {\n            this.text = this.text.slice(0, index) + value + this.text.slice(index);\n            this.domNode.data = this.text;\n        }\n        else {\n            super.insertAt(index, value, def);\n        }\n    }\n    length() {\n        return this.text.length;\n    }\n    optimize(context) {\n        super.optimize(context);\n        this.text = this.statics.value(this.domNode);\n        if (this.text.length === 0) {\n            this.remove();\n        }\n        else if (this.next instanceof TextBlot && this.next.prev === this) {\n            this.insertAt(this.length(), this.next.value());\n            this.next.remove();\n        }\n    }\n    position(index, _inclusive = false) {\n        return [this.domNode, index];\n    }\n    split(index, force = false) {\n        if (!force) {\n            if (index === 0) {\n                return this;\n            }\n            if (index === this.length()) {\n                return this.next;\n            }\n        }\n        const after = this.scroll.create(this.domNode.splitText(index));\n        this.parent.insertBefore(after, this.next || undefined);\n        this.text = this.statics.value(this.domNode);\n        return after;\n    }\n    update(mutations, _context) {\n        if (mutations.some((mutation) => {\n            return (mutation.type === 'characterData' && mutation.target === this.domNode);\n        })) {\n            this.text = this.statics.value(this.domNode);\n        }\n    }\n    value() {\n        return this.text;\n    }\n}\nTextBlot.blotName = 'text';\nTextBlot.scope = Scope.INLINE_BLOT;\nexport default TextBlot;\n"],"sourceRoot":""}