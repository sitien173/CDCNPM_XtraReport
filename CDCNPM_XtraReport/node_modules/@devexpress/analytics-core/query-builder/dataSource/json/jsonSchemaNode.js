/**
* DevExpress Analytics (query-builder\dataSource\json\jsonSchemaNode.js)
* Version:  21.2.7
* Build date: Apr 13, 2022
* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ko = require("knockout");
var serializer_1 = require("../../../serializer/serializer");
var _dbSchema_1 = require("../_dbSchema");
var localization_utils_1 = require("../../../property-grid/localization/localization_utils");
var parsers_1 = require("../../../core/utils/parsers");
var JsonNodeType;
(function (JsonNodeType) {
    JsonNodeType[JsonNodeType["Object"] = 0] = "Object";
    JsonNodeType[JsonNodeType["Array"] = 1] = "Array";
    JsonNodeType[JsonNodeType["Property"] = 2] = "Property";
})(JsonNodeType = exports.JsonNodeType || (exports.JsonNodeType = {}));
var JsonNode = (function () {
    function JsonNode(model, serializer) {
        this.nodes = [];
        if (!model)
            return;
        serializer = serializer || new serializer_1.ModelSerializer();
        serializer.deserialize(this, model);
        var innerNodes = model['Node'];
        var currentNodes = innerNodes instanceof Array ?
            _dbSchema_1.deserializeToCollection(innerNodes, function (nodeModel) { return new JsonNode(nodeModel); }).sort(function (a, b) { return a.name().localeCompare(b.name()); })
            : !innerNodes ? [] : [new JsonNode(innerNodes)];
        this.nodes = currentNodes;
    }
    JsonNode.from = function (model, serializer) {
        return new JsonNode(model, serializer);
    };
    JsonNode.toJsonNodes = function (value, serializer, refs) {
        return (value || []).map(function (item) { return JsonNode.toJsonNode(item, serializer, refs); });
    };
    JsonNode.toJsonNode = function (value, serializer, refs, recoursive) {
        if (recoursive === void 0) { recoursive = true; }
        var obj = serializer.serialize(value, jsonSchemaNodeSerializationInfo, refs);
        var nodes = recoursive ? JsonNode.toJsonNodes(value.nodes, serializer, refs) : [];
        if (nodes.length > 0)
            obj['Node'] = nodes;
        return obj;
    };
    JsonNode.prototype.getInfo = function () {
        return jsonSchemaNodeSerializationInfo;
    };
    return JsonNode;
}());
exports.JsonNode = JsonNode;
var JsonSchemaNode = (function (_super) {
    __extends(JsonSchemaNode, _super);
    function JsonSchemaNode(model, serializer) {
        var _this = _super.call(this, model['Node'], serializer) || this;
        _this.nodeType = JsonNodeType[JsonNodeType.Object];
        _this.valueType = 'Unknown';
        _this.displayName = localization_utils_1.getLocalization('root');
        _this.selected = ko.observable(false);
        return _this;
    }
    JsonSchemaNode.from = function (model, serializer) {
        return new JsonSchemaNode(model || {}, serializer);
    };
    JsonSchemaNode.toJson = function (value, serializer, refs) {
        if (!value)
            return {};
        var obj = { Node: JsonNode.toJsonNode(value, serializer, refs, false) };
        obj.Node['Node'] = JsonNode.toJsonNodes(value.nodes, serializer, refs);
        return obj;
    };
    JsonSchemaNode.prototype.getInfo = function () {
        return jsonSchemaNodeSerializationInfo;
    };
    return JsonSchemaNode;
}(JsonNode));
exports.JsonSchemaNode = JsonSchemaNode;
var JsonSchemaRootNode = (function (_super) {
    __extends(JsonSchemaRootNode, _super);
    function JsonSchemaRootNode(model, serializer) {
        var _this = _super.call(this, model) || this;
        _this._rootElementList = null;
        return _this;
    }
    JsonSchemaRootNode.from = function (model, serializer) {
        return new JsonSchemaRootNode(model, serializer);
    };
    JsonSchemaRootNode.toJson = function (value, serializer, refs) {
        return JsonSchemaNode.toJson(value.nodes[0], serializer, refs);
    };
    JsonSchemaRootNode.prototype.getInfo = function () {
        return jsonSchemaRootNodeSerializationInfo;
    };
    JsonSchemaRootNode.prototype.getRootElementPartList = function (allowObjectRootElements) {
        if (allowObjectRootElements === void 0) { allowObjectRootElements = true; }
        if (this._rootElementList)
            return this._rootElementList;
        if (this.nodes.length === 0)
            return [];
        this._rootElementList = [];
        var node = this.nodes[0];
        var currentPath = {
            fullPath: ko.unwrap(node.name),
            path: '',
            pathParts: [ko.unwrap(node.name)]
        };
        this._fillRootElementList(node, currentPath, allowObjectRootElements);
        this._rootElementList.sort(function (a, b) { return a.fullPath.localeCompare(b.fullPath); });
        return this._rootElementList;
    };
    JsonSchemaRootNode.prototype._fillRootElementList = function (node, currentPath, allowObjectRootElements) {
        var _this = this;
        if (node === void 0) { node = this.nodes[0]; }
        if (currentPath === void 0) { currentPath = { fullPath: 'root', path: '', pathParts: ['root'] }; }
        if (!node)
            return this._rootElementList;
        var nodeType = ko.unwrap(node.nodeType);
        if (nodeType == JsonNodeType[JsonNodeType.Property])
            return;
        if (nodeType === JsonNodeType[JsonNodeType.Array]) {
            this._rootElementList.push(currentPath);
            return;
        }
        if ((allowObjectRootElements && nodeType === JsonNodeType[JsonNodeType.Object])) {
            this._rootElementList.push(currentPath);
        }
        (node.nodes || []).forEach(function (x) {
            var nextPath = _this._getNextPath(currentPath, x.name());
            _this._fillRootElementList(x, nextPath, allowObjectRootElements);
        });
        return this._rootElementList;
    };
    JsonSchemaRootNode.prototype._getNextPath = function (currentPath, nodeName) {
        var _nodeName = !currentPath.fullPath ? nodeName : [currentPath.fullPath, nodeName].join('.');
        return {
            pathParts: currentPath.pathParts.concat(nodeName),
            fullPath: _nodeName,
            path: nodeName
        };
    };
    return JsonSchemaRootNode;
}(JsonNode));
exports.JsonSchemaRootNode = JsonSchemaRootNode;
var jsonSchemaNodeSerializationInfo = [
    { propertyName: 'nodes', modelName: 'Node', from: JsonNode.from, toJsonObject: JsonNode.toJsonNodes },
    { propertyName: 'name', modelName: '@Name' },
    { propertyName: 'selected', modelName: '@Selected', from: parsers_1.parseBool },
    { propertyName: 'nodeType', modelName: '@NodeType' },
    { propertyName: 'type', modelName: '@Type' }
];
var jsonSchemaRootNodeSerializationInfo = [
    { propertyName: 'nodes', modelName: 'Node', from: JsonSchemaRootNode.from, toJsonObject: JsonSchemaRootNode.toJsonNodes }
];
