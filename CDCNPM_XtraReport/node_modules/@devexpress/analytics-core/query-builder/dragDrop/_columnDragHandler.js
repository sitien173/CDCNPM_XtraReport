/**
* DevExpress Analytics (query-builder\dragDrop\_columnDragHandler.js)
* Version:  21.2.7
* Build date: Apr 13, 2022
* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ko = require("knockout");
var _dragDropHandler_1 = require("../../core/dragDrop/_dragDropHandler");
var columnSurface_1 = require("../elements/columnSurface");
var connectionPointSurface_1 = require("../../diagram/elements/connectors/connectionPointSurface");
var _surfaceHelpers_1 = require("../../core/internal/_surfaceHelpers");
var routedConnectorModel_1 = require("../../diagram/elements/connectors/routedConnectorModel");
var routedConnectorSurface_1 = require("../../diagram/elements/connectors/routedConnectorSurface");
var utils_1 = require("../../diagram/utils");
var _scrollProcessor_1 = require("../../core/internal/_scrollProcessor");
var ColumnDragHandler = (function (_super) {
    __extends(ColumnDragHandler, _super);
    function ColumnDragHandler(querySurface, selection, undoEngine, snapHelper, dragHelperContent) {
        var _this = _super.call(this, querySurface, selection, undoEngine, snapHelper, dragHelperContent) || this;
        _this.querySurface = querySurface;
        _this.undoEngine = undoEngine;
        _this._dragColumn = ko.observable(null);
        _this._dragConditionSurface = null;
        _this.dragDropConnector = ko.observable(null);
        _this.cursor = 'arrow';
        _this.containment = '.dxrd-ghost-container';
        _this['helper'] = undefined;
        return _this;
    }
    ColumnDragHandler.prototype._needToCreateRelation = function () {
        if (!(this.selection.dropTarget && this.selection.dropTarget instanceof columnSurface_1.ColumnSurface))
            return false;
        var table = this.selection.dropTarget.getControlModel().parentModel();
        return table !== this.getDragColumn().parentModel();
    };
    ColumnDragHandler.prototype.startDrag = function (control) {
        this._scrollProcessor = new _scrollProcessor_1.dxScrollProcessor(document.getElementsByClassName('dxqb-mainwin')[0]);
        if (control instanceof connectionPointSurface_1.ConnectionPointSurface) {
            var condition = control.getControlModel().parentModel();
            this._dragConditionSurface = _surfaceHelpers_1.findSurface(condition);
            if (!this._dragConditionSurface)
                return;
            this._dragConditionSurface.isVisible(false);
            this._dragColumn((condition.startPoint() === control.getControlModel()) ? condition.nestedColumn() : condition.parentColumn());
        }
        else if (!(control instanceof columnSurface_1.ColumnSurface)) {
            throw new Error('ColumnDragHandler can be applied to the Column only.');
        }
        else {
            this._dragColumn(control.getControlModel());
        }
        var connectorModel = new routedConnectorModel_1.RoutedConnectorViewModel({}, this.querySurface().getControlModel());
        this.dragDropConnector(new routedConnectorSurface_1.RoutedConnectorSurface(connectorModel, this.surface()));
    };
    ColumnDragHandler.prototype.setConnectorPoints = function (cursorPosition) {
        var startColumn = this._dragColumn(), connectorModel = this.dragDropConnector().getControlModel();
        if (this._needToCreateRelation()) {
            var points = utils_1.determineConnectingPoints(startColumn, this.selection.dropTarget.getControlModel());
            connectorModel.startPoint().connectingPoint(points.start);
            connectorModel.endPoint().connectingPoint(points.end);
        }
        else {
            var _leftConnectionPointX = this.querySurface().rtl() ? this.querySurface().pageWidth() - startColumn.leftConnectionPoint.location.x() : startColumn.leftConnectionPoint.location.x();
            var _rightConnectionPointX = this.querySurface().rtl() ? this.querySurface().pageWidth() - startColumn.rightConnectionPoint.location.x() : startColumn.rightConnectionPoint.location.x();
            var point = Math.abs(_leftConnectionPointX - cursorPosition.left) > Math.abs(_rightConnectionPointX - cursorPosition.left) ?
                startColumn.rightConnectionPoint : startColumn.leftConnectionPoint;
            connectorModel.startPoint().connectingPoint(point);
            this.dragDropConnector().endPoint().rect({ top: cursorPosition.top, left: cursorPosition.left });
        }
    };
    ColumnDragHandler.prototype.drag = function (event, ui) {
        var scrollOffset = this._scrollProcessor.getScrollOffset();
        ui.position.left += (ui['scroll'].left + scrollOffset.left);
        ui.position.top += (ui['scroll'].top + scrollOffset.top);
        ui['delta'].left = ui.position.left - this.surface()['underCursor']().x - 6;
        ui['delta'].top = ui.position.top - this.surface()['underCursor']().y - 6;
        this.setConnectorPoints(this._getAbsoluteSurfacePosition(ui));
        this._scrollProcessor.processOffset({ x: event.clientX, y: event.clientY });
    };
    ColumnDragHandler.prototype.doStopDrag = function () {
        this._scrollProcessor.dispose();
        this._scrollProcessor = null;
        this.dragHelperContent.reset();
        this.dragDropConnector(null);
        try {
            var editableCondition = null;
            if (this._dragConditionSurface && !this._dragConditionSurface.isVisible()) {
                editableCondition = this._dragConditionSurface.getControlModel();
                this._dragConditionSurface.isVisible(true);
            }
            var query = this.querySurface().getControlModel();
            if (this._needToCreateRelation()) {
                var nestedColumn = this.selection.dropTarget.getControlModel();
                this.undoEngine().start();
                if (editableCondition) {
                    editableCondition.parentModel().removeChild(editableCondition);
                }
                var condition = query.cerateJoinCondition(this._dragColumn(), nestedColumn);
                this.undoEngine().end();
                if (condition !== null) {
                    this.selection.initialize(_surfaceHelpers_1.findSurface(condition));
                }
            }
        }
        finally {
            this._dragColumn(null);
        }
    };
    ColumnDragHandler.prototype.getDragColumn = function () {
        return this._dragColumn();
    };
    return ColumnDragHandler;
}(_dragDropHandler_1.DragDropHandler));
exports.ColumnDragHandler = ColumnDragHandler;
