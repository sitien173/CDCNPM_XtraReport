/**
* DevExpress Analytics (diagram\utils.js)
* Version:  21.2.7
* Build date: Apr 13, 2022
* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var routedConnectorModel_1 = require("./elements/connectors/routedConnectorModel");
var PointSide;
(function (PointSide) {
    PointSide[PointSide["East"] = 0] = "East";
    PointSide[PointSide["South"] = 1] = "South";
    PointSide[PointSide["North"] = 2] = "North";
    PointSide[PointSide["West"] = 3] = "West";
})(PointSide = exports.PointSide || (exports.PointSide = {}));
function determineConnectingPoints(startObject, endObject) {
    var result = { start: null, end: null };
    if (endObject.leftConnectionPoint.location.x() > startObject.rightConnectionPoint.location.x() + routedConnectorModel_1.RoutedConnectorViewModel.GRID_SIZE * 2) {
        result.start = startObject.rightConnectionPoint;
        result.end = endObject.leftConnectionPoint;
    }
    else if (startObject.leftConnectionPoint.location.x() > endObject.rightConnectionPoint.location.x() + routedConnectorModel_1.RoutedConnectorViewModel.GRID_SIZE * 2) {
        result.start = startObject.leftConnectionPoint;
        result.end = endObject.rightConnectionPoint;
    }
    else {
        var startCenter = (startObject.rightConnectionPoint.location.x() + startObject.rightConnectionPoint.location.x()) / 2;
        var endCenter = (endObject.rightConnectionPoint.location.x() + endObject.rightConnectionPoint.location.x()) / 2;
        if (startCenter > endCenter) {
            result.start = startObject.rightConnectionPoint;
            result.end = endObject.rightConnectionPoint;
        }
        else {
            result.start = startObject.leftConnectionPoint;
            result.end = endObject.leftConnectionPoint;
        }
    }
    return result;
}
exports.determineConnectingPoints = determineConnectingPoints;
