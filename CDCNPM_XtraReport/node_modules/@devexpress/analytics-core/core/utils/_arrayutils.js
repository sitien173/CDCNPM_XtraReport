/**
* DevExpress Analytics (core\utils\_arrayutils.js)
* Version:  21.2.7
* Build date: Apr 13, 2022
* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ko = require("knockout");
var _utils_1 = require("../../serializer/_utils");
function createObservableReverseArrayMapCollection(elementModels, target, createItem) {
    var array = target();
    elementModels.peek().forEach(function (item) {
        var surface = createItem(item);
        array.splice(0, 0, surface);
    });
    target.valueHasMutated();
    return elementModels.subscribe(function (args) {
        var unwrapedTarget = target();
        var targetLength = unwrapedTarget.length;
        args.forEach(function (changeSet) {
            if (changeSet.status === 'deleted') {
                unwrapedTarget.splice(unwrapedTarget.indexOf(changeSet.value.surface), 1);
                targetLength--;
            }
        });
        args.forEach(function (changeSet) {
            if (changeSet.status === 'added') {
                unwrapedTarget.splice(targetLength - changeSet.index, 0, createItem(changeSet.value));
                targetLength++;
            }
        });
        target.valueHasMutated();
    }, null, 'arrayChange');
}
exports.createObservableReverseArrayMapCollection = createObservableReverseArrayMapCollection;
function createObservableArrayMapCollection(elementModels, target, createItem) {
    var array = target();
    elementModels.peek().forEach(function (item) {
        var surface = createItem(item);
        array.push(surface);
    });
    target.valueHasMutated();
    return elementModels.subscribe(function (args) {
        var startIndex = target().length, deleteCount = 0, valuesToAdd = [];
        args.forEach(function (changeSet) {
            if (changeSet.status === 'deleted') {
                deleteCount++;
                if (changeSet.index < startIndex) {
                    startIndex = changeSet.index;
                }
            }
        });
        args.forEach(function (changeSet) {
            if (changeSet.status === 'added') {
                if (changeSet.index < startIndex) {
                    startIndex = changeSet.index;
                }
                valuesToAdd.push(createItem(changeSet.value));
            }
        });
        target.splice.apply(target, [startIndex, deleteCount].concat(valuesToAdd));
    }, null, 'arrayChange');
}
exports.createObservableArrayMapCollection = createObservableArrayMapCollection;
function deserializeChildArray(model, parent, creator) {
    var result = Object.keys(model || {}).map(function (propertyName) { return creator(model[propertyName]); });
    return _utils_1.knockoutArrayWrapper(result, function (array, event) {
        if (event === 'beforeChange') {
            return;
        }
        if (event === 'arrayChange') {
            for (var i = 0; i < array.length; i++) {
                parent !== array[i].value.parentModel() && array[i].value.parentModel(parent);
            }
        }
        else {
            for (var i = 0; i < array.length; i++) {
                parent !== array[i].parentModel() && array[i].parentModel(parent);
            }
        }
    });
}
exports.deserializeChildArray = deserializeChildArray;
function getFirstItemByPropertyValue(array, propertyName, propertyValue, fromIndex) {
    var fromIndex = fromIndex || 0;
    for (var i = fromIndex; i < array.length; i++) {
        var value = ko.isObservable(array[i][propertyName]) ? array[i][propertyName].peek() : array[i][propertyName];
        if (value === propertyValue) {
            return array[i];
        }
    }
    return null;
}
exports.getFirstItemByPropertyValue = getFirstItemByPropertyValue;
function findFirstItemMatchesCondition(array, predicate) {
    for (var i = 0; i < array.length; i++) {
        if (predicate(array[i])) {
            return array[i];
        }
    }
    return null;
}
exports.findFirstItemMatchesCondition = findFirstItemMatchesCondition;
exports.find = findFirstItemMatchesCondition;
function binaryIndexOf(ar, el, compare) {
    var m = 0;
    var n = ar.length - 1;
    while (m <= n) {
        var k = (n + m) >> 1;
        var cmp = compare(el, ar[k]);
        if (cmp > 0) {
            m = k + 1;
        }
        else if (cmp < 0) {
            n = k - 1;
        }
        else {
            return k;
        }
    }
    return ~m;
}
exports.binaryIndexOf = binaryIndexOf;
