/**
* DevExpress Analytics (core\selection\_selection.d.ts)
* Version:  21.2.7
* Build date: Apr 13, 2022
* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { IArea } from '../elements/baseSurface';
import { IHoverInfo } from '../internal/_hoverInfo';
import { ElementViewModel } from '../elements/elementViewModel';
import { IDisposable, Disposable } from '../../serializer/utils';
import { TreeListItemViewModel } from '../../widgets/treelist/_treelistItem';
export interface ISelectingEvent {
    control: ISelectionTarget;
    cancel: boolean;
    ctrlKey?: boolean;
}
export interface ISelectionTarget {
    rect: ko.Observable<IArea> | ko.Computed<IArea>;
    focused: ko.Observable<boolean> | ko.Computed<boolean>;
    selected: ko.Observable<boolean> | ko.Computed<boolean>;
    underCursor: ko.Observable<IHoverInfo> | ko.Computed<IHoverInfo>;
    allowMultiselect: boolean;
    locked: boolean;
    canDrop: () => boolean;
    getControlModel: () => ElementViewModel;
    checkParent: (surfaceParent: ISelectionTarget) => boolean;
    parent: ISelectionTarget;
    getChildrenCollection: () => ko.ObservableArray<ISelectionTarget>;
    dragCallback?: (item: TreeListItemViewModel) => void;
    dropCallback?: (item: TreeListItemViewModel) => void;
    findNextSelection?: () => ISelectionTarget;
}
export interface ISelectionProvider extends IDisposable {
    focused: ko.Observable<ISelectionTarget> | ko.Computed<ISelectionTarget>;
    selectedItems: ISelectionTarget[];
    initialize(surface?: ISelectionTarget): any;
    selecting(event: ISelectingEvent): any;
    unselecting(surface: ISelectionTarget): any;
    swapFocusedItem(surface: ISelectionTarget): any;
    ignoreMultiSelectProperties?: string[];
    selectionWithCtrl(surface?: ISelectionTarget): any;
    applySelection(): any;
}
export declare class SurfaceSelection extends Disposable implements ISelectionProvider {
    ignoreMultiSelectProperties: string[];
    dispose(): void;
    private _focused;
    private _firstSelected;
    private _selectedControls;
    private _selectedControlsInner;
    private _removeFromSelection;
    private _setFocused;
    private _resetTabPanelFocus;
    constructor(ignoreMultiSelectProperties?: string[]);
    focused: ko.PureComputed<ISelectionTarget>;
    readonly selectedItems: ISelectionTarget[];
    clear(): void;
    reset(): void;
    applySelection(): void;
    selectItems(items: any): void;
    updateSelection(control: ISelectionTarget): void;
    swapFocusedItem(control: ISelectionTarget): void;
    initialize(control?: ISelectionTarget): void;
    clickHandler(control?: ISelectionTarget, event?: {
        ctrlKey: boolean;
        metaKey: boolean;
    }): void;
    selecting(event: ISelectingEvent): void;
    unselecting(control: ISelectionTarget): void;
    selectionWithCtrl(control: ISelectionTarget): void;
    dropTarget: ISelectionTarget;
    expectClick: boolean;
    disabled: ko.Observable<boolean>;
}
