/**
* DevExpress Analytics (core\tools\_keyboardHelper.js)
* Version:  21.2.7
* Build date: Apr 13, 2022
* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $ = require("jquery");
var _internal_1 = require("../../serializer/_internal");
var utils_1 = require("../../serializer/utils");
var _utils_1 = require("../../property-grid/widgets/internal/_utils");
var KeyboardHelperBase = (function (_super) {
    __extends(KeyboardHelperBase, _super);
    function KeyboardHelperBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    KeyboardHelperBase.prototype._processShortcut = function (map, e, index) {
        var method = map[_utils_1.KeyboardCodesEnum[e.keyCode]];
        if (method) {
            return method(e, index);
        }
        return false;
    };
    KeyboardHelperBase.prototype.processShortcut = function (e, index) {
        return this._processShortcut(this.shortcutMap, e, index);
    };
    KeyboardHelperBase.prototype.processChildrenShortcut = function (e, index) {
        return this._processShortcut(this.childrenShortcutMap, e, index);
    };
    return KeyboardHelperBase;
}(utils_1.Disposable));
exports.KeyboardHelperBase = KeyboardHelperBase;
var KeyboardHelper = (function (_super) {
    __extends(KeyboardHelper, _super);
    function KeyboardHelper(selection, undoEngine) {
        var _this = _super.call(this) || this;
        _this._selection = selection;
        _this._undoEngine = undoEngine;
        _this.shortcutMap = {
            Esc: function (e) { _this.processEsc(); return true; },
            Left: function (e) { _this.moveSelectedControls(true, true, -1); return true; },
            Up: function (e) { _this.moveSelectedControls(true, false, -1); return true; },
            Right: function (e) { _this.moveSelectedControls(false, true, 1); return true; },
            Down: function (e) { _this.moveSelectedControls(false, false, 1); return true; }
        };
        return _this;
    }
    KeyboardHelper.prototype.processEsc = function () {
        var parent = this._selection.focused() && this._selection.focused().parent;
        parent && this._selection.focused(parent);
    };
    KeyboardHelper.prototype.moveSelectedControls = function (leftUp, isHoriz, sign) {
        var focusedControl = this._selection.focused();
        if (!focusedControl || focusedControl && focusedControl.getControlModel().getMetaData().isCopyDeny) {
            return;
        }
        this._undoEngine && this._undoEngine().start();
        var distance = 1, axisProperty = isHoriz ? 'left' : 'top', lengthProperty = isHoriz ? 'width' : 'height', minAxis, maxSide, newAxis;
        if (focusedControl.rect) {
            minAxis = focusedControl.rect()[axisProperty];
            maxSide = focusedControl.rect()[axisProperty] + focusedControl.rect()[lengthProperty];
        }
        else {
            return;
        }
        this._selection.selectedItems.filter(function (item) { return !item.locked; }).forEach(function (item) {
            var axis = item.rect()[axisProperty];
            if (axis < minAxis) {
                minAxis = axis;
            }
        });
        this._selection.selectedItems.filter(function (item) { return !item.locked; }).forEach(function (item) {
            var side = item.rect()[axisProperty] + item.rect()[lengthProperty];
            if (side > maxSide) {
                maxSide = side;
            }
        });
        if ((leftUp && minAxis <= 0) || (!focusedControl.parent.rect || (!leftUp && maxSide.toFixed(5) >= focusedControl.parent.rect()[lengthProperty]))) {
            return;
        }
        else {
            this._selection.selectedItems.filter(function (item) { return !item.locked; })
                .filter(function (item) { return !!item.rect; })
                .forEach(function (item) {
                var newVal = {}, itemAxisProperty = item.rect()[axisProperty], itemLengthProperty = item.rect()[lengthProperty], parentLengthProperty = item.parent.rect()[lengthProperty];
                newAxis = itemAxisProperty + sign * distance;
                if ((leftUp && newAxis >= 0) || (!leftUp && (newAxis + itemLengthProperty) <= parentLengthProperty)) {
                    newVal[axisProperty] = newAxis;
                }
                if (!leftUp && (newAxis + itemLengthProperty) > parentLengthProperty) {
                    newVal[axisProperty] = parentLengthProperty - itemLengthProperty;
                }
                if (leftUp && newAxis < 0 && itemAxisProperty > 0) {
                    newVal[axisProperty] = 0;
                }
                item.rect(newVal);
            });
        }
        this._undoEngine && this._undoEngine().end();
    };
    return KeyboardHelper;
}(KeyboardHelperBase));
exports.KeyboardHelper = KeyboardHelper;
var KeyDownHandlersManager = (function () {
    function KeyDownHandlersManager(targetElement) {
        this._handlers = [];
        this._targetElement = targetElement;
    }
    Object.defineProperty(KeyDownHandlersManager.prototype, "_activeHandler", {
        get: function () {
            return this._handlers.length > 0 ? this._handlers[this._handlers.length - 1] : null;
        },
        enumerable: true,
        configurable: true
    });
    KeyDownHandlersManager.prototype._removeHandler = function (handler, eventName) {
        var index = this._handlers.indexOf(handler);
        if (index < 0)
            return;
        this._handlers.splice(index, 1);
        if (index === this._handlers.length) {
            this._targetElement.removeEventListener(eventName, handler);
            if (this._activeHandler)
                this._targetElement.addEventListener(eventName, this._activeHandler);
        }
    };
    KeyDownHandlersManager.prototype.bindHandler = function (element, handler, eventName) {
        var _this = this;
        if (eventName === void 0) { eventName = 'keydown'; }
        if (this._activeHandler)
            this._targetElement.removeEventListener(eventName, this._activeHandler);
        var _handler = function (e) {
            if ($(_this._targetElement).closest('.dx-designer').length > 0 ||
                $(e.target).closest('.dx-designer').length > 0 ||
                e.target === document.body)
                handler(e);
        };
        this._handlers.push(_handler);
        this._targetElement.addEventListener(eventName, _handler);
        _internal_1.addDisposeCallback(element, function () { _this._removeHandler(_handler, eventName); });
    };
    return KeyDownHandlersManager;
}());
exports.KeyDownHandlersManager = KeyDownHandlersManager;
