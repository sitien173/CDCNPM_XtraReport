/**
* DevExpress Analytics (core\snapLines\_snapLinesHelper.js)
* Version:  21.2.7
* Build date: Apr 13, 2022
* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _snapLinesCollector_1 = require("./_snapLinesCollector");
var _snapLineSurface_1 = require("./_snapLineSurface");
var _arrayutils_1 = require("../utils/_arrayutils");
var SnapLinesHelper = (function () {
    function SnapLinesHelper(surface, snapTolerance, snapLinesCollector) {
        if (surface === void 0) { surface = null; }
        if (snapTolerance === void 0) { snapTolerance = SnapLinesHelper.snapTolerance; }
        if (snapLinesCollector === void 0) { snapLinesCollector = new _snapLinesCollector_1.SnapLinesCollector(); }
        this.snapLineSurfaces = [new _snapLineSurface_1.SnapLineSurface(), new _snapLineSurface_1.SnapLineSurface(), new _snapLineSurface_1.SnapLineSurface(), new _snapLineSurface_1.SnapLineSurface()];
        this.verticalSnapLines = [];
        this.horizontalSnapLines = [];
        this._surfaceContext = surface;
        this._snapTolerance = snapTolerance;
        this._snapLinesCollector = snapLinesCollector;
    }
    SnapLinesHelper.prototype._findClosestSnapLine = function (position, snapLines) {
        var line = {
            position: position,
            limitInf: 0,
            limSup: 0
        };
        var index = _arrayutils_1.binaryIndexOf(snapLines, line, function (a, b) { return a.position - b.position; });
        var snapLineCandidate;
        if (index > -1) {
            snapLineCandidate = {
                snapLine: snapLines[index],
                distance: position - snapLines[index].position
            };
        }
        else {
            index = ~index;
            var delta1 = snapLines[index] ? (position - snapLines[index].position) : Number.MAX_VALUE;
            var delta2 = snapLines[index - 1] ? (position - snapLines[index - 1].position) : Number.MAX_VALUE;
            snapLineCandidate = Math.abs(delta1) > Math.abs(delta2) ?
                { snapLine: snapLines[index - 1], distance: delta2 } :
                { snapLine: snapLines[index], distance: delta1 };
        }
        return snapLineCandidate;
    };
    SnapLinesHelper.prototype._getActiveSnapLines = function (position1, position2, snapLines) {
        var line1 = this._findClosestSnapLine(position1, snapLines);
        var line2 = this._findClosestSnapLine(position2, snapLines);
        var result = {
            lines: [],
            distance: 0
        };
        if (Math.abs(line1.distance - line2.distance) >= 1) {
            var line = Math.abs(line1.distance) < Math.abs(line2.distance) ? line1 : line2;
            if (Math.abs(line.distance) <= this._snapTolerance) {
                result.lines = [line];
                result.distance = line.distance;
            }
        }
        else if (Math.abs(line1.distance) <= this._snapTolerance) {
            result.lines = [line1, line2];
            result.distance = line1.distance;
        }
        return result;
    };
    SnapLinesHelper.prototype.updateSnapLines = function (snapTargetToIgnore) {
        if (snapTargetToIgnore === void 0) { snapTargetToIgnore = null; }
        this.verticalSnapLines.splice(0);
        this.horizontalSnapLines.splice(0);
        var result = this._snapLinesCollector.collectSnaplines(this._surfaceContext(), snapTargetToIgnore);
        this.verticalSnapLines.push.apply(this.verticalSnapLines, result.vertical);
        this.horizontalSnapLines.push.apply(this.horizontalSnapLines, result.horizontal);
    };
    SnapLinesHelper.prototype.deactivateSnapLines = function () {
        this.snapLineSurfaces[0].reset();
        this.snapLineSurfaces[1].reset();
        this.snapLineSurfaces[2].reset();
        this.snapLineSurfaces[3].reset();
    };
    SnapLinesHelper.prototype.activateSnapLines = function (position) {
        var vertical = this._getActiveSnapLines(position.left, position.right, this.verticalSnapLines);
        var horizontal = this._getActiveSnapLines(position.top, position.bottom, this.horizontalSnapLines);
        for (var i = 0; i < 2; i++) {
            var line = vertical.lines[i];
            if (!line) {
                this.snapLineSurfaces[i].reset();
            }
            else {
                var top = Math.min(line.snapLine.limitInf, position.top);
                var bottom = Math.max(line.snapLine.limSup, position.bottom);
                if (position.top < line.snapLine.limitInf) {
                    top -= horizontal.distance;
                }
                if (position.bottom > line.snapLine.limSup) {
                    bottom -= horizontal.distance;
                }
                this.snapLineSurfaces[i].updatePosition({
                    top: top,
                    left: line.snapLine.position,
                    height: bottom - top,
                    width: 1
                });
            }
        }
        for (var i = 0; i < 2; i++) {
            var line = horizontal.lines[i];
            if (!line) {
                this.snapLineSurfaces[i + 2].reset();
            }
            else {
                var left = Math.min(line.snapLine.limitInf, position.left);
                var right = Math.max(line.snapLine.limSup, position.right);
                if (position.left < line.snapLine.limitInf) {
                    left -= vertical.distance;
                }
                if (position.right > line.snapLine.limSup) {
                    right -= vertical.distance;
                }
                this.snapLineSurfaces[i + 2].updatePosition({
                    top: line.snapLine.position,
                    left: left,
                    width: right - left,
                    height: 1
                });
            }
        }
        return {
            left: vertical.distance,
            top: horizontal.distance
        };
    };
    SnapLinesHelper.prototype.snapPosition = function (position, horizontal) {
        var line = this._findClosestSnapLine(position, horizontal ? this.horizontalSnapLines : this.verticalSnapLines);
        return (line && Math.abs(line.distance) <= this._snapTolerance) ? line.snapLine.position : position;
    };
    SnapLinesHelper.snapTolerance = 10;
    return SnapLinesHelper;
}());
exports.SnapLinesHelper = SnapLinesHelper;
