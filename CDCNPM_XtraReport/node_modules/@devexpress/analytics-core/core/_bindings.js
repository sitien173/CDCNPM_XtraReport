/**
* DevExpress Analytics (core\_bindings.js)
* Version:  21.2.7
* Build date: Apr 13, 2022
* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ko = require("knockout");
var $ = require("jquery");
require("jquery-ui/ui/widgets/draggable");
require("jquery-ui/ui/widgets/resizable");
require("jquery-ui/ui/widgets/selectable");
require("jquery-ui/ui/widgets/mouse");
var _internal_1 = require("../serializer/_internal");
var _dragDropHandler_1 = require("./dragDrop/_dragDropHandler");
var _utils_1 = require("./utils/_utils");
var _keyboardHelper_1 = require("./tools/_keyboardHelper");
var _utils_2 = require("../serializer/_utils");
var _utils_3 = require("../property-grid/widgets/internal/_utils");
var templateUtils_1 = require("../property-grid/widgets/templateUtils");
ko.bindingHandlers['cssArray'] = {
    'update': function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        for (var i = 0; i < value.length; i++) {
            ko.bindingHandlers['css'].update(element, function () { return value[i]; });
        }
    }
};
ko.bindingHandlers['selectable'] = {
    init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        var values = valueAccessor(), isUpdate = false, $element = $(element), selection = ko.unwrap(values.selection), options = _utils_2.extend({ filter: '.dxd-selectable', distance: 1 }, ko.unwrap(values), {
            selecting: function (event, ui) {
                var _event = { control: ko.dataFor(ui.selecting), cancel: false, ctrlKey: event.ctrlKey };
                selection.selecting(_event);
                if (_event.cancel) {
                    $(ui.selecting).removeClass('ui-selecting');
                }
            },
            start: function (event, ui) {
                selection.clickHandler(null, event);
                selection.started = true;
                event.stopPropagation();
            },
            stop: function () {
                selection.started = false;
                selection.applySelection();
            },
            unselecting: function (event, ui) {
                selection.unselecting(ko.dataFor(ui.unselecting));
            },
            classes: {
                'ui-selectable-helper': 'dxrd-selection-content'
            }
        });
        $element['selectable'](options);
        var subscriptions = [];
        var subscribeProperty = function (property, optionName) {
            if (property && ko.isSubscribable(property)) {
                subscriptions.push(property.subscribe(function (newVal) {
                    $element['selectable']('option', optionName, newVal);
                }));
            }
        };
        subscribeProperty(selection.disabled, 'disabled');
        subscribeProperty(values.zoom, 'zoom');
        _internal_1.addDisposeCallback(element, function () {
            if ($element.data('ui-selectable')) {
                $element['selectable']('destroy');
            }
            $element = null;
            subscribeProperty = null;
            subscriptions.forEach(function (x) { return x.dispose(); });
        });
    }
};
ko.bindingHandlers['updateTop'] = {
    init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        var value = valueAccessor();
        var $element = $(element);
        var updateTop = function (value) {
            var scaleY = element.getBoundingClientRect().height / element.offsetHeight;
            var top = (value === 0 || !!value) ? value : ($element.prev().position().top / scaleY) + $element.prev().outerHeight();
            $element.css('top', top + 'px');
        };
        var subscription = value.subscribe(function (newVal) {
            updateTop(newVal);
        });
        updateTop(value());
        _internal_1.addDisposeCallback(element, function () {
            subscription.dispose();
        });
    }
};
ko.bindingHandlers['draggable'] = {
    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        var values = valueAccessor();
        if (!values)
            return;
        var $element = $(element), $parent = values.parent && values.parent() || $element.closest('.dx-designer-viewport'), containment = values.containment || '.dxrd-ghost-container', $viewport, $ghostContainerOffset, $containmentOffset, initialScroll = { left: 0, top: 0 }, attachDelta = function (ui) {
            ui['delta'] = {
                left: ($ghostContainerOffset && $ghostContainerOffset.left || 0) - $containmentOffset.left,
                top: ($ghostContainerOffset && $ghostContainerOffset.top || 0) - $containmentOffset.top
            };
            ui['scroll'] = {
                left: $viewport.scrollLeft() - initialScroll.left,
                top: $viewport.scrollTop() - initialScroll.top
            };
        }, options = _utils_2.extend({}, ko.unwrap(values), {
            start: function (event, ui) {
                _dragDropHandler_1.DragDropHandler.started(true);
                var draggable = $element.data('ui-draggable');
                $viewport = $parent.find('.dxrd-viewport');
                $ghostContainerOffset = $parent.find('.dxrd-ghost-container').offset();
                $containmentOffset = $parent.find(containment).offset();
                initialScroll.left = $viewport.scrollLeft();
                initialScroll.top = $viewport.scrollTop();
                values.startDrag && values.startDrag(ko.dataFor(event.currentTarget || event.toElement));
            },
            stop: function (event, ui) {
                attachDelta(ui);
                values.stopDrag(ui, ko.dataFor(event.target), event);
                _dragDropHandler_1.DragDropHandler.started(false);
            },
            drag: function (event, ui) {
                attachDelta(ui);
                values.drag && values.drag(event, ui);
            },
            helper: function (event) {
                var $container;
                if (values.helper) {
                    $container = values.helper(ko.dataFor(event.currentTarget || event['toElement']), event);
                    if ($container)
                        return $container;
                }
                var templateHtml = templateUtils_1.getTemplate(bindingContext.$root.dragHelperContent.template);
                $container = $(templateHtml).css({ 'display': values.helper ? 'block' : 'none' });
                $container.prependTo($parent.find(options.containment));
                ko.applyBindingsToDescendants(bindingContext.$root.dragHelperContent, $container[0]);
                return $container;
            }
        });
        options.containment = $parent.find(options.containment);
        $element['draggable'](options);
        _internal_1.addDisposeCallback(element, function () {
            if ($element.data('ui-draggable'))
                $element['draggable']('destroy');
        });
    }
};
var trackCursorData = 'dxd-track-cursor-data';
var trackCursorClass = 'dxd-track-cursor';
var trackCursorSelector = '.' + trackCursorClass;
var dragHelperLineClass = 'dxrd-drag-helper-item';
ko.bindingHandlers['trackCursor'] = {
    init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        var $element = $(element);
        $element.addClass(trackCursorClass);
        var value = valueAccessor();
        var recalculateBounds = false;
        if (value['recalculateBounds']) {
            recalculateBounds = value['recalculateBounds'];
            value = value['underCursor'];
        }
        var bounds = element.getBoundingClientRect(), body = document.body, docElem = document.documentElement, overHandler = function (event) {
            if (!(bindingContext.$root.selection.started && bindingContext.$root.resizeHandler.started)) {
                if (!value().isNotDropTarget) {
                    bindingContext.$root.selection.dropTarget = bindingContext.$data;
                    event.stopPropagation();
                }
            }
        }, enterHandler = function (event) {
            value(_utils_2.extend(value(), { isOver: true }));
            if (!(bindingContext.$root.selection.started && bindingContext.$root.resizeHandler.started)) {
                bounds = element.getBoundingClientRect();
            }
        }, leaveHandler = function (event) {
            value(_utils_2.extend(value(), { isOver: false }));
        }, handler = function (event) {
            if (recalculateBounds)
                bounds = element.getBoundingClientRect();
            if (!(bindingContext.$root.selection.started && bindingContext.$root.resizeHandler.started)) {
                var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop, scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft, clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0, y = event.pageY - (bounds.top + scrollTop - clientTop), x = event.pageX - (bounds.left + scrollLeft - clientLeft);
                value(_utils_2.extend(value(), { x: x, y: y }));
            }
        };
        element.addEventListener('mousemove', handler);
        !recalculateBounds && element.addEventListener('mouseenter', enterHandler);
        element.addEventListener('mouseover', overHandler);
        element.addEventListener('mouseleave', leaveHandler);
        element.addEventListener('dragover', handler);
        _internal_1.addDisposeCallback(element, function () {
            element.removeEventListener('dragover', handler);
            element.removeEventListener('mousemove', handler);
            element.removeEventListener('mouseover', overHandler);
            element.removeEventListener('mouseleave', leaveHandler);
            !recalculateBounds && element.removeEventListener('mouseenter', enterHandler);
            $element.removeClass(trackCursorClass);
        });
    }
};
ko.bindingHandlers['templates'] = {
    init: function (element, valueAccessor) {
        var templateHtml = $(valueAccessor()).text(), $templateHtml = $(templateHtml);
        $(element).append($templateHtml);
        return { controlsDescendantBindings: true };
    }
};
ko.bindingHandlers['zoom'] = {
    update: function (element, valueAccessor) {
        var value = ko.unwrap(valueAccessor() || {});
        for (var i = 0; i < _utils_1.cssTransform.length; i++) {
            element.style[_utils_1.cssTransform[i]] = 'scale(' + (value) + ')';
        }
        $(element).addClass('dxrd-transform-origin-left-top');
    }
};
ko.bindingHandlers['keyDownActions'] = (function () {
    var handlersManager = new _keyboardHelper_1.KeyDownHandlersManager(window);
    return {
        init: function (element, valueAccessor) {
            var actionLists = valueAccessor(), handler = function (e) { actionLists.processShortcut(ko.unwrap(actionLists.toolbarItems), e); };
            if (ko.isSubscribable(actionLists.enabled)) {
                var subscribe = actionLists.enabled.subscribe(function (newVal) {
                    if (newVal)
                        handlersManager.bindHandler(element, handler);
                });
                _internal_1.addDisposeCallback(element, function () { return subscribe.dispose(); });
            }
            if (ko.unwrap(actionLists.enabled))
                handlersManager.bindHandler(element, handler);
        }
    };
})();
ko.bindingHandlers['accessibilityKeyboardHelper'] = (function () {
    return {
        init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            var handlersManager = valueAccessor();
            if (handlersManager && (bindingContext.$root.accessibilityCompliant || handlersManager.accessibilityCompliantEnabled)) {
                var subscription = ko.bindingEvent.subscribe(element, 'childrenComplete', function () {
                    handlersManager.bindHandler(element);
                });
                _internal_1.addDisposeCallback(element, function () {
                    subscription.dispose();
                });
            }
        }
    };
})();
ko.bindingHandlers['dxAction'] = (function () {
    return {
        init: function (element, valueAccessor) {
            var values = valueAccessor();
            var clickHandler = function (e) {
                values.action.call(values.model, values.model, e);
            };
            var keyPressHandler = function (e) {
                if (e.key == _utils_3.KeyboardEnum.Enter || e.key == _utils_3.KeyboardEnum.Space) {
                    values.action.call(values.model, values.model, e);
                }
            };
            element.addEventListener('click', clickHandler);
            element.addEventListener('keydown', keyPressHandler);
            _internal_1.addDisposeCallback(element, function () {
                element.removeEventListener('click', clickHandler);
                element.removeEventListener('keydown', keyPressHandler);
            });
        }
    };
})();
ko.extenders.dxdnum = function (target, value) {
    target.subscribe(function (newValue) {
        if (value.max) {
            target(Math.min(newValue, value.max));
        }
        else if (value.min) {
            target(Math.max(newValue, value.min));
        }
    });
    return target;
};
