/**
* DevExpress Analytics (serializer\utils.js)
* Version:  21.2.7
* Build date: Apr 13, 2022
* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ko = require("knockout");
var Disposable = (function () {
    function Disposable() {
        this._disposables = [];
        this.isDisposing = false;
    }
    Disposable.prototype.disposeObservableArray = function (array) {
        if (array) {
            array().forEach(function (item) { item.dispose && item.dispose(); });
        }
    };
    Disposable.prototype.resetObservableArray = function (array) {
        if (array)
            array([]);
    };
    Disposable.prototype.disposeArray = function (array) {
        if (array) {
            array.forEach(function (item) { item.dispose && item.dispose(); });
            array.splice(0, array.length);
        }
    };
    Disposable.prototype.dispose = function () {
        if (!this.isDisposing) {
            this.isDisposing = true;
            (this._disposables || []).reverse().forEach(function (x) { return x && x.dispose && x.dispose(); });
            this._disposables = [];
        }
    };
    Disposable.prototype.removeProperties = function () {
        var _this = this;
        Object.keys(this).forEach(function (propertyName) {
            delete _this[propertyName];
        });
    };
    return Disposable;
}());
exports.Disposable = Disposable;
function deserializeArray(model, creator) {
    var result = Object.keys(model || {}).map(function (propertyName) { return creator(model[propertyName]); });
    return ko.observableArray(result);
}
exports.deserializeArray = deserializeArray;
function toStringWithDelimiter(values, delimiter) {
    return (values || []).map(function (value) {
        var str = value !== undefined && value !== null ? value.toString() : '00';
        if (str.length === 1) {
            str = '0' + str;
        }
        return str;
    }).join(delimiter);
}
function serializeDate(date) {
    var datePart = [date.getMonth() + 1, date.getDate(), date.getFullYear()];
    var timePart = toStringWithDelimiter([date.getHours(), date.getMinutes(), date.getSeconds()], ':');
    return timePart === '00:00:00' ? toStringWithDelimiter([datePart[2], datePart[0], datePart[1]], '-')
        : toStringWithDelimiter(datePart, '/') + ' ' + timePart;
}
exports.serializeDate = serializeDate;
function deserializeDate(dateTime) {
    var dateTimeParts = dateTime.split(' ');
    var dateArgs = dateTimeParts[0].split('-');
    var timeArgs = [0, 0, 0];
    if (dateTimeParts.length > 1) {
        dateArgs = dateTimeParts[0].split('/');
        dateArgs.splice(0, 0, dateArgs.splice(2, 1)[0]);
        timeArgs = dateTimeParts[1].split(':').map(function (x) { return parseInt(x); });
        if (timeArgs.length !== 3)
            return null;
    }
    if (dateArgs.length !== 3)
        return null;
    dateArgs = dateArgs.map(function (x) { return parseInt(x); });
    return new Date(dateArgs[0], dateArgs[1] - 1, dateArgs[2], timeArgs[0], timeArgs[1], timeArgs[2]);
}
exports.deserializeDate = deserializeDate;
