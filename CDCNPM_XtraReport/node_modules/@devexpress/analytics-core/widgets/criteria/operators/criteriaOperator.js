/**
* DevExpress Analytics (widgets\criteria\operators\criteriaOperator.js)
* Version:  21.2.7
* Build date: Apr 13, 2022
* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var $ = require("jquery");
var _utils_1 = require("../../../property-grid/widgets/internal/_utils");
function getEnumNames(enumType) {
    var result = [];
    Object.keys(enumType).forEach(function (enumValue) {
        if (isNaN(enumValue)) {
            result.push(enumValue);
        }
    });
    return result;
}
var MachineState = (function () {
    function MachineState(tokenName, alphabet, startTerm, endTerm) {
        this.tokenName = tokenName;
        this.alphabet = alphabet;
        this.startTerm = startTerm;
        this.endTerm = endTerm;
        this.tokenLength = 0;
        this.isActiveState = false;
        this.tokens = [];
    }
    MachineState.prototype._isSubline = function (pos, term) {
        var result = (pos + term.length - 1 < this.alphabet.length);
        for (var i = pos; i < (pos + term.length) && result; i++)
            result = this.alphabet[i] == term[i - pos];
        return result;
    };
    MachineState.prototype._getToken = function (pos) {
        var token = {
            type: this.tokenName, start: pos - this.tokenLength + 1, end: pos + this.endTerm.length
        };
        token.val = this.alphabet.substring(token.start, token.end);
        return token;
    };
    MachineState.prototype.processTransitionFunction = function (pos) {
        if (this.isActiveState) {
            this.tokenLength++;
        }
        if (this._isSubline(pos, this.startTerm) && !this.isActiveState) {
            this.isActiveState = true;
            this.tokenLength += this.startTerm.length;
            return this.startTerm.length - 1;
        }
        else if (this.isActiveState && this._isSubline(pos, this.endTerm)) {
            this.isActiveState = false;
            this.tokens.push(this._getToken(pos));
            this.tokenLength = 0;
            return this.endTerm.length - 1;
        }
        return 0;
    };
    return MachineState;
}());
exports.MachineState = MachineState;
var CriteriaOperatorStateMachine = (function () {
    function CriteriaOperatorStateMachine(stringCriteria) {
        this.stringCriteria = stringCriteria;
        this.machineStates = [];
        this.machineStates.push(new MachineState('field', stringCriteria, '[', ']'));
        this.machineStates.push(new MachineState('value', stringCriteria, "'", "'"));
        this.machineStates.push(new MachineState('comment', stringCriteria, '/*', '*/'));
        this._inputStringCriteria = stringCriteria;
    }
    CriteriaOperatorStateMachine.prototype._tokenize = function () {
        var _this = this;
        for (var i = 0; i < this.stringCriteria.length; i++) {
            var step = 0;
            this.machineStates.forEach(function (state) {
                if (step)
                    return;
                var anotherMachines = _this.machineStates.filter(function (a) { return a != state && a.isActiveState; });
                if (!anotherMachines.length)
                    step = state.processTransitionFunction(i);
            });
            i += step;
        }
        var resultTokens = [];
        this.machineStates.forEach(function (state) {
            resultTokens = resultTokens.concat(state.tokens);
            state.tokens = [];
        });
        return resultTokens;
    };
    CriteriaOperatorStateMachine.prototype._replaceTokenToAnotherToken = function (tokens, newTokenChar, tokenName) {
        var tempCriteria = this.stringCriteria;
        tokens = tokens.filter(function (a) { return a.type == tokenName; }).sort(function (a) { return a.start; }).reverse();
        tokens.forEach(function (token) {
            var lines = token.val.split('\n');
            var start = token.start;
            var end = token.end;
            lines.forEach(function (line) {
                if (line.length + start !== token.end) {
                    end = start + line.length;
                }
                else {
                    end = token.end;
                }
                tempCriteria = _utils_1.stringReplace(tempCriteria, start, end - start, newTokenChar);
                start = (line.length * newTokenChar.length) + 1;
            });
        });
        return tempCriteria;
    };
    CriteriaOperatorStateMachine.prototype.replaceCommentsToChar = function (char) {
        if (char === void 0) { char = ''; }
        this._inputStringCriteria = this._replaceTokenToAnotherToken(this._tokenize(), char, 'comment');
        return this;
    };
    CriteriaOperatorStateMachine.prototype.getCriteria = function () {
        return criteriaparser_1.parse(this._inputStringCriteria);
    };
    return CriteriaOperatorStateMachine;
}());
exports.CriteriaOperatorStateMachine = CriteriaOperatorStateMachine;
var CriteriaOperator = (function () {
    function CriteriaOperator() {
        var _this = this;
        this.type = 'Default';
        this.operands = null;
        this.changeValueType = function (type, location) {
            var result = new type();
            if (location.index !== null) {
                _this[location.name][location.index] = result;
            }
            else {
                _this[location.name] = result;
            }
            return result;
        };
        this.changeValue = function (operand, reverse, location) {
            var result = reverse ? new unary_1.UnaryOperator(unary_1.UnaryOperatorType.Minus, operand) : operand;
            if (location.index !== null) {
                _this[location.name][location.index] = result;
            }
            else {
                _this[location.name] = result;
            }
            return result;
        };
        this.assignLeftPart = function (criteriaOperator) { return void 0; };
        this.assignRightPart = function (criteriaOperator) { return void 0; };
        this.assignType = function (type) {
            _this.operatorType = type;
        };
        this.resetrightPart = function (value) { return void 0; };
    }
    CriteriaOperator.operators = function (enums) {
        var result = [].concat.apply([], enums.map(function (enumType) {
            return getEnumNames(enumType).map(function (enumName) {
                return { name: enumName, value: enumType[enumName], type: enumType };
            });
        }));
        return result;
    };
    CriteriaOperator.parse = function (stringCriteria, saveOriginalStringLength) {
        if (saveOriginalStringLength === void 0) { saveOriginalStringLength = false; }
        if (stringCriteria && stringCriteria !== '') {
            if (saveOriginalStringLength)
                return new CriteriaOperatorStateMachine(stringCriteria).replaceCommentsToChar(' ').getCriteria();
            return new CriteriaOperatorStateMachine(stringCriteria).replaceCommentsToChar().getCriteria();
        }
        return null;
    };
    CriteriaOperator.create = function (operatorType) {
        var operator = null;
        switch (operatorType.type) {
            case binary_1.BinaryOperatorType:
                operator = new binary_1.BinaryOperator(new property_1.OperandProperty(), new value_1.OperandValue(), operatorType.value);
                break;
            case group_1.GroupOperatorType:
                operator = new group_1.GroupOperator(operatorType.value, []);
                break;
            case function_1.FunctionOperatorType:
                operator = new function_1.FunctionOperator(operatorType.value, [new property_1.OperandProperty()]);
                break;
            case between_1.BetweenOperator:
                operator = new between_1.BetweenOperator(new property_1.OperandProperty(), new value_1.OperandValue(), new value_1.OperandValue());
                break;
            case in_1.InOperator:
                operator = new in_1.InOperator(new property_1.OperandProperty(), [new value_1.OperandValue()]);
                break;
            case unary_1.UnaryOperatorType:
                operator = new unary_1.UnaryOperator(operatorType.value, new property_1.OperandProperty());
                break;
            case aggregate_1.Aggregate:
                var result = new aggregate_1.AggregateOperand(new property_1.OperandProperty(), null, operatorType.value, new group_1.GroupOperator(group_1.GroupOperatorType.And, []));
                if (operatorType.value === aggregate_1.Aggregate.Exists) {
                    operator = result;
                }
                else {
                    if (operatorType.value !== aggregate_1.Aggregate.Count) {
                        result.aggregatedExpression = new property_1.OperandProperty();
                    }
                    operator = new binary_1.BinaryOperator(result, new value_1.OperandValue(), binary_1.BinaryOperatorType.Equal);
                }
                break;
            default:
                throw Error('Unsupported operator type');
        }
        if (operatorType.reverse) {
            return new unary_1.UnaryOperator(unary_1.UnaryOperatorType.Not, operator);
        }
        return operator;
    };
    CriteriaOperator.and = function (left, right) {
        return group_1.GroupOperator.combine(group_1.GroupOperatorType.Or, [left, right]);
    };
    CriteriaOperator.or = function (left, right) {
        return group_1.GroupOperator.combine(group_1.GroupOperatorType.Or, [left, right]);
    };
    CriteriaOperator.getNotValidRange = function (value, errorMessage) {
        var start = 0;
        var end = 0;
        var parts = errorMessage.split('\n');
        var errorText = parts[1];
        var errorLength = parts[2].length;
        if (errorText.indexOf('...') === 0) {
            errorText = errorText.split('...')[1];
        }
        var start = value.indexOf(errorText);
        var end = start + errorLength;
        return { start: start, end: end };
    };
    Object.defineProperty(CriteriaOperator.prototype, "displayType", {
        get: function () {
            return this.operatorType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CriteriaOperator.prototype, "enumType", {
        get: function () {
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CriteriaOperator.prototype, "leftPart", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CriteriaOperator.prototype, "rightPart", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    CriteriaOperator.prototype.assignFrom = function (criteriaOperator, incorrectSpecificsForAggregate, needAssignRightPart) {
        if (incorrectSpecificsForAggregate === void 0) { incorrectSpecificsForAggregate = false; }
        if (needAssignRightPart === void 0) { needAssignRightPart = true; }
        var operator = criteriaOperator;
        if (criteriaOperator instanceof unary_1.UnaryOperator && !(criteriaOperator.leftPart instanceof property_1.OperandProperty)) {
            operator = criteriaOperator.leftPart;
        }
        if (incorrectSpecificsForAggregate) {
            this.assignLeftPart(operator.leftPart);
        }
        else {
            this.assignLeftPart(operator);
        }
        if (operator.rightPart) {
            needAssignRightPart && this.assignRightPart(operator);
        }
    };
    CriteriaOperator.prototype.children = function () {
        var operands = [];
        if (this.leftPart)
            operands.push.apply(operands, $.isArray(this.leftPart) ? this.leftPart : [this.leftPart]);
        if (this.rightPart)
            operands.push.apply(operands, $.isArray(this.rightPart) ? this.rightPart : [this.rightPart]);
        return operands;
    };
    CriteriaOperator.prototype.accept = function (visitor) { throw 'Not implemented'; };
    return CriteriaOperator;
}());
exports.CriteriaOperator = CriteriaOperator;
var binary_1 = require("./binary");
var property_1 = require("./property");
var value_1 = require("./value");
var group_1 = require("./group");
var function_1 = require("./function");
var between_1 = require("./between");
var in_1 = require("./in");
var unary_1 = require("./unary");
var aggregate_1 = require("./aggregate");
var criteriaparser_1 = require("../parser/criteriaparser");
