/**
* DevExpress Analytics (widgets\internal\_valueEditorHelper.js)
* Version:  21.2.7
* Build date: Apr 13, 2022
* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var $ = require("jquery");
var _utils_1 = require("../../serializer/_utils");
var ValueEditorHelper = (function () {
    function ValueEditorHelper() {
    }
    ValueEditorHelper._getCharFromKeyCode = function (e) {
        if (e.ctrlKey === false && e.key.length === 1)
            return e.key;
        return null;
    };
    ValueEditorHelper._getCaretPosition = function (el) {
        var start = -1, end = -1, normalizedValue, range, textInputRange, len, endRange;
        try {
            if (typeof el.selectionStart == 'number' && typeof el.selectionEnd == 'number') {
                start = el.selectionStart;
                end = el.selectionEnd;
            }
            else if (document['selection']) {
                range = document['selection'].createRange();
                if (range && range.parentElement() == el) {
                    len = el.value.length;
                    normalizedValue = el.value.replace(/\r\n/g, '\n');
                    textInputRange = el.createTextRange();
                    textInputRange.moveToBookmark(range.getBookmark());
                    endRange = el.createTextRange();
                    endRange.collapse(false);
                    if (textInputRange.compareEndPoints('StartToEnd', endRange) > -1) {
                        start = end = len;
                    }
                    else {
                        start = -textInputRange.moveStart('character', -len);
                        start += normalizedValue.slice(0, start).split('\n').length - 1;
                        if (textInputRange.compareEndPoints('EndToEnd', endRange) > -1) {
                            end = len;
                        }
                        else {
                            end = -textInputRange.moveEnd('character', -len);
                            end += normalizedValue.slice(0, end).split('\n').length - 1;
                        }
                    }
                }
            }
        }
        catch (e) {
        }
        return {
            start: start,
            end: end
        };
    };
    ValueEditorHelper._validate = function (value, minValue, maxValue) {
        var _a, _b, _c, _d;
        if (!/^(0|(-?(([1-9]\d*)|(0\.\d+)|([1-9]\d*\.\d+)|(\d*\.\d+[eE][+\-]?\d+))))$/.test(value))
            return false;
        if (!maxValue)
            return true;
        var negative = value[0] === '-';
        var valModulo = negative ? value.substring(1) : value;
        if (negative && !minValue)
            return false;
        var boundModulo = negative ? minValue.substring(1) : maxValue;
        var valMantissa, valExp, boundMantissa, boundExp;
        _a = valModulo.toLowerCase().split('e'), valMantissa = _a[0], valExp = _a[1];
        _b = boundModulo.toLowerCase().split('e'), boundMantissa = _b[0], boundExp = _b[1];
        var valIntPart, valFracPart, boundIntPart, boundFracPart;
        _c = valMantissa.split('.'), valIntPart = _c[0], valFracPart = _c[1];
        _d = boundMantissa.split('.'), boundIntPart = _d[0], boundFracPart = _d[1];
        valIntPart = (valIntPart || '').replace(/^0+/, '');
        boundIntPart = (boundIntPart || '').replace(/^0+/, '');
        var valOrder = valIntPart.length;
        if (valExp)
            valOrder += parseInt(valExp);
        var boundOrder = boundIntPart.length;
        if (boundExp)
            boundOrder += parseInt(boundExp);
        if (valOrder < boundOrder)
            return true;
        if (valOrder > boundOrder)
            return false;
        valFracPart = valFracPart || '0';
        boundFracPart = boundFracPart || '0';
        if (valIntPart + valFracPart > boundIntPart + boundFracPart)
            return false;
        return true;
    };
    ValueEditorHelper.validateWidgetValue = function (e, validate, defaultVal) {
        var currentValue = e.component.option('value');
        if (!validate(currentValue)) {
            e.component.option('value', defaultVal);
        }
    };
    ValueEditorHelper.getNumberEditorOptions = function (id, specifics, extendOptions) {
        if (extendOptions === void 0) { extendOptions = {}; }
        var editorOptions = ValueEditorHelper.editors[id] || ValueEditorHelper.editors[specifics];
        return editorOptions ? ValueEditorHelper.getValueEditorOptions(editorOptions.regExpEditing, function (value) {
            return ValueEditorHelper._validate(value, editorOptions.minValue, editorOptions.maxValue);
        }, '', extendOptions) : extendOptions;
    };
    ValueEditorHelper.getValueEditorOptions = function (regExpEditing, validate, defaultVal, extendOptions) {
        var _this = this;
        if (extendOptions === void 0) { extendOptions = {}; }
        var options = {
            onFocusIn: function (e) {
                ValueEditorHelper.validateWidgetValue(e, validate, defaultVal);
                ValueEditorHelper._invokeStandardHandler(extendOptions, 'onFocusIn', e);
            },
            onKeyDown: function (e) {
                var char = ValueEditorHelper._getCharFromKeyCode(e.event);
                if (!char)
                    return;
                var $input = $(e.element).find('input').eq(0);
                var caretPosition = ValueEditorHelper._getCaretPosition($input.get(0));
                var currentValue = $input.val();
                if (caretPosition.start < 0) {
                    caretPosition = currentValue ? currentValue.length : 0;
                }
                var result = [currentValue.slice(0, caretPosition.start), char, currentValue.slice(caretPosition.end)].join('');
                if (!regExpEditing.test(result))
                    e.event.preventDefault();
                $input = null;
                ValueEditorHelper._invokeStandardHandler(extendOptions, 'onKeyDown', e);
            },
            onPaste: function (e) {
                var clipboardData = e.event.originalEvent.clipboardData || window['clipboardData'] || {};
                var pastedData = clipboardData.getData && clipboardData.getData('Text');
                if (typeof pastedData !== 'string')
                    return;
                var $input = $(e.element).find('input').eq(0);
                var caretPosition = ValueEditorHelper._getCaretPosition($input.get(0));
                var currentValue = $input.val();
                if (caretPosition.start < 0) {
                    caretPosition.end = caretPosition.start = currentValue ? currentValue.length : 0;
                }
                var result = [
                    currentValue.slice(0, caretPosition.start), pastedData, currentValue.slice(caretPosition.end)
                ].join('');
                if (!regExpEditing.test(result))
                    e.event.preventDefault();
                $input = null;
                ValueEditorHelper._invokeStandardHandler(extendOptions, 'onPaste', e);
            },
            onValueChanged: function (e) {
                if (e.value !== defaultVal)
                    _this.validateWidgetValue(e, validate, e.previousValue);
                ValueEditorHelper._invokeStandardHandler(extendOptions, 'onValueChanged', e);
            }
        };
        return _utils_1.extend({}, extendOptions, options);
    };
    ValueEditorHelper.isValid = function (id, specifics, value) {
        var editorOptions = ValueEditorHelper.editors[id] || ValueEditorHelper.editors[specifics];
        return editorOptions.regExpEditing.test(value) && ValueEditorHelper._validate(value, editorOptions.minValue, editorOptions.maxValue);
    };
    ValueEditorHelper._invokeStandardHandler = function (extendOptions, name, e) {
        if ($.isFunction(extendOptions[name]))
            extendOptions[name](e);
    };
    ValueEditorHelper.editors = {
        'integer': {
            regExpEditing: /^-?\d*$/
        },
        'float': {
            regExpEditing: /^-?(\d+\.?\d*)?([eE][+\-]?\d+)?$/
        },
        'System.Byte': {
            regExpEditing: /^\d*$/,
            minValue: null,
            maxValue: '255'
        },
        'System.SByte': {
            regExpEditing: /^-?\d*$/,
            minValue: '-128',
            maxValue: '127'
        },
        'System.Int16': {
            regExpEditing: /^-?\d*$/,
            minValue: '-32768',
            maxValue: '32767'
        },
        'System.UInt16': {
            regExpEditing: /^\d*$/,
            minValue: null,
            maxValue: '65535'
        },
        'System.Int32': {
            regExpEditing: /^-?\d*$/,
            minValue: '-2147483648',
            maxValue: '2147483647'
        },
        'System.UInt32': {
            regExpEditing: /^\d*$/,
            minValue: null,
            maxValue: '4294967295'
        },
        'System.Int64': {
            regExpEditing: /^-?\d*$/,
            minValue: '-9223372036854775808',
            maxValue: '9223372036854775807'
        },
        'System.UInt64': {
            regExpEditing: /^\d*$/,
            minValue: null,
            maxValue: '18446744073709551615'
        },
        'System.Single': {
            regExpEditing: /^-?(\d+\.?\d*)?([eE][+\-]?\d*)?$/,
            minValue: '-3.40282347e+38',
            maxValue: '3.40282347e+38'
        },
        'System.Double': {
            regExpEditing: /^-?(\d+\.?\d*)?([eE][+\-]?\d*)?$/,
            minValue: '-1.7976931348623157e+308',
            maxValue: '1.7976931348623157e+308'
        },
        'System.Decimal': {
            regExpEditing: /^-?(\d+\.?\d*)?([eE][+\-]?\d*)?$/,
            minValue: '-79228162514264337593543950335',
            maxValue: '79228162514264337593543950335'
        }
    };
    return ValueEditorHelper;
}());
exports.ValueEditorHelper = ValueEditorHelper;
