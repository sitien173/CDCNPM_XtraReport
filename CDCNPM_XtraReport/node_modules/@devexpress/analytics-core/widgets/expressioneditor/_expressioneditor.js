/**
* DevExpress Analytics (widgets\expressioneditor\_expressioneditor.js)
* Version:  21.2.7
* Build date: Apr 13, 2022
* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ko = require("knockout");
var localization_utils_1 = require("../../property-grid/localization/localization_utils");
exports.RangeSpecific = 'range';
function createExpressionEditorCollectionToolOptions(collectionItems, toolName, displayToolName, showDescription) {
    return {
        displayName: localization_utils_1.getLocalization(toolName, displayToolName),
        content: {
            showDescription: showDescription,
            isSelected: ko.observable(false),
            data: {
                items: collectionItems,
                selectedItem: ko.observable(null)
            },
            name: 'dx-expressioneditor-collection'
        },
        dispose: function () { return void 0; }
    };
}
exports.createExpressionEditorCollectionToolOptions = createExpressionEditorCollectionToolOptions;
function wrapExpressionValue(path, value, converter, subscriptions) {
    if (!(converter && path))
        return value;
    var _displayValue = ko.observable(value());
    converter.toDisplayExpression(path(), value()).done(function (result) {
        _displayValue(result);
    }).fail(function () {
        _displayValue(value());
    });
    var valueSubscription = value.subscribe(function (newValue) {
        converter.toDisplayExpression(path(), newValue).done(function (result) {
            _displayValue(result);
        }).fail(function () {
            _displayValue(newValue);
        });
    });
    var pathSubscription = path.subscribe(function (newPath) {
        converter.toDisplayExpression(newPath, value())
            .done(function (result) { _displayValue(result); })
            .fail(function (_) { _displayValue(value()); });
    });
    var displayValue = ko.pureComputed({
        read: function () { return _displayValue(); },
        write: function (newValue) {
            _displayValue(newValue);
            converter.toRealExpression(path(), newValue).done(function (result) {
                value(result);
            }).fail(function () {
                value(newValue);
            });
        }
    });
    if (subscriptions)
        [displayValue, valueSubscription, pathSubscription].forEach(function (x) { return subscriptions.push(x); });
    return displayValue;
}
exports.wrapExpressionValue = wrapExpressionValue;
