import { ExtendedMin, ExtendedMinMax, MinMax, ExtendedMax } from '../class/min-max';
import { ConstInterval } from '../intervals/const';
import { CmpFunc, ICloneable, IEquatable } from '../types';
export declare class ListUtils {
    static remove<T>(list: T[], element: T): void;
    static removeBy<T>(list: T[], callback: (currVal: T, index: number) => boolean): T | null;
    static shallowCopy<T>(list: T[]): T[];
    static deepCopy<T extends ICloneable<T>>(list: readonly T[]): T[];
    static initByValue<T>(numElements: number, initValue: T): T[];
    static initByCallback<T>(numElements: number, initCallback: (index: number) => T): T[];
    static forEachOnInterval(interval: ConstInterval, callback: (index: number) => void): void;
    static reverseForEachOnInterval(interval: ConstInterval, callback: (index: number) => void): void;
    static reducedMap<T, TRes>(list: readonly T[], callback: (currVal: T, index: number) => TRes | null, startIndex?: number, endIndex?: number): TRes[];
    static filter<T>(list: readonly T[], callback: (currVal: T, index: number) => boolean, startIndex?: number, endIndex?: number): T[];
    static map<T, TRes>(list: readonly T[], callback: (currVal: T, index: number) => TRes, startIndex?: number, endIndex?: number): TRes[];
    static indexBy<T>(list: readonly T[], callback: (currElement: T, index: number) => boolean, startIndex?: number, endIndex?: number): number;
    static reverseIndexBy<T>(list: readonly T[], callback: (currElement: T, index: number) => boolean, startIndex?: number, endIndex?: number): number;
    static elementBy<T>(list: readonly T[], callback: (currElement: T, index: number) => boolean, startIndex?: number, endIndex?: number): T | null;
    static reverseElementBy<T>(list: readonly T[], callback: (currElement: T, index: number) => boolean, startIndex?: number, endIndex?: number): T | null;
    static last<T>(list: readonly T[]): T;
    static setLast<T>(list: T[], newVal: T): T;
    static incLast(list: number[]): number;
    static decLast(list: number[]): number;
    static equals<T extends IEquatable<T>>(a: T[], b: T[]): boolean;
    static equalsByReference(a: any[], b: any[]): boolean;
    static unique<T>(list: T[], cmp: CmpFunc<T>, equal?: CmpFunc<T>, finalizeObj?: (obj: T) => void): T[];
    static uniqueNumber(list: number[]): number[];
    static forEach<T>(list: readonly T[], callback: (value: T, index: number) => void, startIndex?: number, endIndex?: number): void;
    static forEach2<TA, TB>(listA: readonly TA[], listB: readonly TB[], callback: (valueA: TA, valueB: TB, index: number) => void, startIndex?: number, endIndex?: number): void;
    static reverseForEach<T>(list: readonly T[], callback: (value: T, index: number) => void, startIndex?: number, endIndex?: number): void;
    static reverseIndexOf<T>(list: readonly T[], element: T, startIndex?: number, endIndex?: number): number;
    static accumulate<T, TAcc>(list: readonly T[], initAccValue: TAcc, callback: (acc: TAcc, currVal: T, index: number) => TAcc, startIndex?: number, endIndex?: number): TAcc;
    static accumulateNumber<T>(list: readonly T[], callback: (currVal: T, index: number, acc: number) => number, initAccValue?: number, startIndex?: number, endIndex?: number): number;
    static anyOf<T>(list: readonly T[], callback: (currVal: T, index: number) => boolean, startIndex?: number, endIndex?: number): boolean;
    static unsafeAnyOf<T, TRes>(list: readonly T[], callback: (currVal: T, index: number) => TRes | null | undefined, startIndex?: number, endIndex?: number): TRes | null;
    static reverseAnyOf<T>(list: readonly T[], callback: (currVal: T, index: number) => boolean, startIndex?: number, endIndex?: number): boolean;
    static unsafeReverseAnyOf<T, TRes>(list: readonly T[], callback: (currVal: T, index: number) => TRes | null | undefined, startIndex?: number, endIndex?: number): TRes | null;
    static anyOf2<TA, TB>(listA: readonly TA[], listB: TB[], callback: (currValA: TA, currValB: TB, index: number) => boolean, startIndex?: number, endIndex?: number): boolean;
    static allOf<T>(list: readonly T[], callback: (currVal: T, index: number) => boolean, startIndex?: number, endIndex?: number): boolean;
    static allOf2<TA, TB>(listA: readonly TA[], listB: TB[], callback: (currValA: TA, currValB: TB, index: number) => boolean, startIndex?: number, endIndex?: number): boolean;
    static allOfOnInterval(interval: ConstInterval, callback: (index: number) => boolean): boolean;
    static addListOnTail<T>(resultList: T[], addedList: readonly T[]): T[];
    static joinLists<T, TRes>(converter: (list: T[]) => TRes[], ...lists: T[][]): TRes[];
    static push<T>(list: T[], element: T): T[];
    static countIf<T>(list: readonly T[], callback: (currElement: T, index: number) => boolean): number;
    static clear<T>(list: T[]): void;
    static merge<T>(list: T[], cmp: CmpFunc<T>, shouldMerge: (a: T, b: T) => boolean, merge: (toMerge: T, fromMerge: T) => void, startIndex?: number, endIndex?: number): T[];
    static min<T>(list: readonly T[], getValue: (val: T) => number, startIndex?: number, endIndex?: number): T | null;
    static max<T>(list: readonly T[], getValue: (val: T) => number, startIndex?: number, endIndex?: number): T | null;
    static minMax<T>(list: readonly T[], getValue: (val: T) => number, startIndex?: number, endIndex?: number): MinMax<T> | null;
    static minExtended<T>(list: readonly T[], getValue: (val: T) => number, startIndex?: number, endIndex?: number): ExtendedMin<T> | null;
    static maxExtended<T>(list: readonly T[], getValue: (val: T) => number, startIndex?: number, endIndex?: number): ExtendedMax<T> | null;
    static minMaxExtended<T>(list: readonly T[], getValue: (val: T) => number, startIndex?: number, endIndex?: number): ExtendedMinMax<T> | null;
    static minByCmp<T>(list: readonly T[], cmp: CmpFunc<T>, startIndex?: number, endIndex?: number): T | null;
    static maxByCmp<T>(list: readonly T[], cmp: CmpFunc<T>, startIndex?: number, endIndex?: number): T | null;
    static minMaxByCmp<T>(list: readonly T[], cmp: CmpFunc<T>, startIndex?: number, endIndex?: number): MinMax<T> | null;
}
//# sourceMappingURL=list.d.ts.map
